// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto v0.17.2
// source: canoto.go

package examples

import (
	"io"
	"reflect"
	"sync/atomic"

	"github.com/StephenButtolph/canoto"
)

// Ensure that unused imports do not error
var (
	_ atomic.Uint64

	_ = io.ErrUnexpectedEOF
)

const (
	canoto__LargestFieldNumber__Uint = 536870911

	canoto__LargestFieldNumber__Uint__tag = "\xf8\xff\xff\xff\x0f" // canoto.Tag(canoto__LargestFieldNumber__Uint, canoto.Varint)
)

type canotoData_LargestFieldNumber struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*LargestFieldNumber[T1]) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero LargestFieldNumber[T1]
	s := &canoto.Spec{
		Name: "LargestFieldNumber",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__LargestFieldNumber__Uint,
				Name:        "Uint",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*LargestFieldNumber[T1]) MakeCanoto() *LargestFieldNumber[T1] {
	return new(LargestFieldNumber[T1])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *LargestFieldNumber[T1]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *LargestFieldNumber[T1]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = LargestFieldNumber[T1]{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__LargestFieldNumber__Uint:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *LargestFieldNumber[T1]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *LargestFieldNumber[T1]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.Uint) {
		size += uint64(len(canoto__LargestFieldNumber__Uint__tag)) + canoto.SizeUint(c.Uint)
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *LargestFieldNumber[T1]) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *LargestFieldNumber[T1]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *LargestFieldNumber[T1]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Uint) {
		canoto.Append(&w, canoto__LargestFieldNumber__Uint__tag)
		canoto.AppendUint(&w, c.Uint)
	}
	return w
}

const (
	canoto__OneOf__A1 = 1
	canoto__OneOf__B1 = 3
	canoto__OneOf__B2 = 4
	canoto__OneOf__C  = 5
	canoto__OneOf__D  = 6
	canoto__OneOf__A2 = 7

	canoto__OneOf__A1__tag = "\x08" // canoto.Tag(canoto__OneOf__A1, canoto.Varint)
	canoto__OneOf__B1__tag = "\x18" // canoto.Tag(canoto__OneOf__B1, canoto.Varint)
	canoto__OneOf__B2__tag = "\x20" // canoto.Tag(canoto__OneOf__B2, canoto.Varint)
	canoto__OneOf__C__tag  = "\x28" // canoto.Tag(canoto__OneOf__C, canoto.Varint)
	canoto__OneOf__D__tag  = "\x30" // canoto.Tag(canoto__OneOf__D, canoto.Varint)
	canoto__OneOf__A2__tag = "\x38" // canoto.Tag(canoto__OneOf__A2, canoto.Varint)
)

type canotoData_OneOf struct {
	size uint64

	AOneOf uint32
	BOneOf uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*OneOf) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero OneOf
	s := &canoto.Spec{
		Name: "OneOf",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__OneOf__A1,
				Name:        "A1",
				OneOf:       "A",
				TypeInt:     canoto.SizeOf(zero.A1),
			},
			{
				FieldNumber: canoto__OneOf__B1,
				Name:        "B1",
				OneOf:       "B",
				TypeInt:     canoto.SizeOf(zero.B1),
			},
			{
				FieldNumber: canoto__OneOf__B2,
				Name:        "B2",
				OneOf:       "B",
				TypeInt:     canoto.SizeOf(zero.B2),
			},
			{
				FieldNumber: canoto__OneOf__C,
				Name:        "C",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.C),
			},
			{
				FieldNumber: canoto__OneOf__D,
				Name:        "D",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.D),
			},
			{
				FieldNumber: canoto__OneOf__A2,
				Name:        "A2",
				OneOf:       "A",
				TypeInt:     canoto.SizeOf(zero.A2),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*OneOf) MakeCanoto() *OneOf {
	return new(OneOf)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *OneOf) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *OneOf) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = OneOf{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__OneOf__A1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.AOneOf, 1) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A1); err != nil {
				return err
			}
			if canoto.IsZero(c.A1) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOf__B1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.BOneOf, 3) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B1); err != nil {
				return err
			}
			if canoto.IsZero(c.B1) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOf__B2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.BOneOf, 4) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B2); err != nil {
				return err
			}
			if canoto.IsZero(c.B2) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOf__C:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOf__D:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.D); err != nil {
				return err
			}
			if canoto.IsZero(c.D) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOf__A2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.AOneOf, 7) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A2); err != nil {
				return err
			}
			if canoto.IsZero(c.A2) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *OneOf) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var AOneOf uint32
	var BOneOf uint32
	if !canoto.IsZero(c.A1) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = canoto__OneOf__A1
	}
	if !canoto.IsZero(c.B1) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = canoto__OneOf__B1
	}
	if !canoto.IsZero(c.B2) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = canoto__OneOf__B2
	}
	if !canoto.IsZero(c.A2) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = canoto__OneOf__A2
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *OneOf) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	var AOneOf uint32
	var BOneOf uint32
	if !canoto.IsZero(c.A1) {
		size += uint64(len(canoto__OneOf__A1__tag)) + canoto.SizeInt(c.A1)
		AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		size += uint64(len(canoto__OneOf__B1__tag)) + canoto.SizeInt(c.B1)
		BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		size += uint64(len(canoto__OneOf__B2__tag)) + canoto.SizeInt(c.B2)
		BOneOf = 4
	}
	if !canoto.IsZero(c.C) {
		size += uint64(len(canoto__OneOf__C__tag)) + canoto.SizeInt(c.C)
	}
	if !canoto.IsZero(c.D) {
		size += uint64(len(canoto__OneOf__D__tag)) + canoto.SizeInt(c.D)
	}
	if !canoto.IsZero(c.A2) {
		size += uint64(len(canoto__OneOf__A2__tag)) + canoto.SizeInt(c.A2)
		AOneOf = 7
	}
	atomic.StoreUint64(&c.canotoData.size, size)
	atomic.StoreUint32(&c.canotoData.AOneOf, AOneOf)
	atomic.StoreUint32(&c.canotoData.BOneOf, BOneOf)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *OneOf) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// CachedWhichOneOfA returns the previously calculated field number used
// to represent A.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfA() uint32 {
	return atomic.LoadUint32(&c.canotoData.AOneOf)
}

// CachedWhichOneOfB returns the previously calculated field number used
// to represent B.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfB() uint32 {
	return atomic.LoadUint32(&c.canotoData.BOneOf)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *OneOf) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *OneOf) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	cachedWhichOneOfA := atomic.LoadUint32(&c.canotoData.AOneOf)
	if cachedWhichOneOfA == 1 {
		canoto.Append(&w, canoto__OneOf__A1__tag)
		canoto.AppendInt(&w, c.A1)
	}
	cachedWhichOneOfB := atomic.LoadUint32(&c.canotoData.BOneOf)
	switch cachedWhichOneOfB {
	case canoto__OneOf__B1:
		canoto.Append(&w, canoto__OneOf__B1__tag)
		canoto.AppendInt(&w, c.B1)
	case canoto__OneOf__B2:
		canoto.Append(&w, canoto__OneOf__B2__tag)
		canoto.AppendInt(&w, c.B2)
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__OneOf__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	if !canoto.IsZero(c.D) {
		canoto.Append(&w, canoto__OneOf__D__tag)
		canoto.AppendInt(&w, c.D)
	}
	if cachedWhichOneOfA == 7 {
		canoto.Append(&w, canoto__OneOf__A2__tag)
		canoto.AppendInt(&w, c.A2)
	}
	return w
}

const (
	canoto__OneOfNoCopy__A1 = 1
	canoto__OneOfNoCopy__B1 = 3
	canoto__OneOfNoCopy__B2 = 4
	canoto__OneOfNoCopy__C  = 5
	canoto__OneOfNoCopy__D  = 6
	canoto__OneOfNoCopy__A2 = 7

	canoto__OneOfNoCopy__A1__tag = "\x08" // canoto.Tag(canoto__OneOfNoCopy__A1, canoto.Varint)
	canoto__OneOfNoCopy__B1__tag = "\x18" // canoto.Tag(canoto__OneOfNoCopy__B1, canoto.Varint)
	canoto__OneOfNoCopy__B2__tag = "\x20" // canoto.Tag(canoto__OneOfNoCopy__B2, canoto.Varint)
	canoto__OneOfNoCopy__C__tag  = "\x28" // canoto.Tag(canoto__OneOfNoCopy__C, canoto.Varint)
	canoto__OneOfNoCopy__D__tag  = "\x30" // canoto.Tag(canoto__OneOfNoCopy__D, canoto.Varint)
	canoto__OneOfNoCopy__A2__tag = "\x38" // canoto.Tag(canoto__OneOfNoCopy__A2, canoto.Varint)
)

type canotoData_OneOfNoCopy struct {
	size atomic.Uint64

	AOneOf atomic.Uint32
	BOneOf atomic.Uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*OneOfNoCopy) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero OneOfNoCopy
	s := &canoto.Spec{
		Name: "OneOfNoCopy",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__OneOfNoCopy__A1,
				Name:        "A1",
				OneOf:       "A",
				TypeInt:     canoto.SizeOf(zero.A1),
			},
			{
				FieldNumber: canoto__OneOfNoCopy__B1,
				Name:        "B1",
				OneOf:       "B",
				TypeInt:     canoto.SizeOf(zero.B1),
			},
			{
				FieldNumber: canoto__OneOfNoCopy__B2,
				Name:        "B2",
				OneOf:       "B",
				TypeInt:     canoto.SizeOf(zero.B2),
			},
			{
				FieldNumber: canoto__OneOfNoCopy__C,
				Name:        "C",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.C),
			},
			{
				FieldNumber: canoto__OneOfNoCopy__D,
				Name:        "D",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.D),
			},
			{
				FieldNumber: canoto__OneOfNoCopy__A2,
				Name:        "A2",
				OneOf:       "A",
				TypeInt:     canoto.SizeOf(zero.A2),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*OneOfNoCopy) MakeCanoto() *OneOfNoCopy {
	return new(OneOfNoCopy)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *OneOfNoCopy) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *OneOfNoCopy) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = OneOfNoCopy{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__OneOfNoCopy__A1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.AOneOf.Swap(1) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A1); err != nil {
				return err
			}
			if canoto.IsZero(c.A1) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOfNoCopy__B1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.BOneOf.Swap(3) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B1); err != nil {
				return err
			}
			if canoto.IsZero(c.B1) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOfNoCopy__B2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.BOneOf.Swap(4) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B2); err != nil {
				return err
			}
			if canoto.IsZero(c.B2) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOfNoCopy__C:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOfNoCopy__D:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.D); err != nil {
				return err
			}
			if canoto.IsZero(c.D) {
				return canoto.ErrZeroValue
			}
		case canoto__OneOfNoCopy__A2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.AOneOf.Swap(7) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A2); err != nil {
				return err
			}
			if canoto.IsZero(c.A2) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *OneOfNoCopy) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var AOneOf uint32
	var BOneOf uint32
	if !canoto.IsZero(c.A1) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = canoto__OneOfNoCopy__A1
	}
	if !canoto.IsZero(c.B1) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = canoto__OneOfNoCopy__B1
	}
	if !canoto.IsZero(c.B2) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = canoto__OneOfNoCopy__B2
	}
	if !canoto.IsZero(c.A2) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = canoto__OneOfNoCopy__A2
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *OneOfNoCopy) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	var AOneOf uint32
	var BOneOf uint32
	if !canoto.IsZero(c.A1) {
		size += uint64(len(canoto__OneOfNoCopy__A1__tag)) + canoto.SizeInt(c.A1)
		AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		size += uint64(len(canoto__OneOfNoCopy__B1__tag)) + canoto.SizeInt(c.B1)
		BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		size += uint64(len(canoto__OneOfNoCopy__B2__tag)) + canoto.SizeInt(c.B2)
		BOneOf = 4
	}
	if !canoto.IsZero(c.C) {
		size += uint64(len(canoto__OneOfNoCopy__C__tag)) + canoto.SizeInt(c.C)
	}
	if !canoto.IsZero(c.D) {
		size += uint64(len(canoto__OneOfNoCopy__D__tag)) + canoto.SizeInt(c.D)
	}
	if !canoto.IsZero(c.A2) {
		size += uint64(len(canoto__OneOfNoCopy__A2__tag)) + canoto.SizeInt(c.A2)
		AOneOf = 7
	}
	c.canotoData.size.Store(size)
	c.canotoData.AOneOf.Store(AOneOf)
	c.canotoData.BOneOf.Store(BOneOf)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *OneOfNoCopy) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// CachedWhichOneOfA returns the previously calculated field number used
// to represent A.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOfNoCopy) CachedWhichOneOfA() uint32 {
	return c.canotoData.AOneOf.Load()
}

// CachedWhichOneOfB returns the previously calculated field number used
// to represent B.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOfNoCopy) CachedWhichOneOfB() uint32 {
	return c.canotoData.BOneOf.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *OneOfNoCopy) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *OneOfNoCopy) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	cachedWhichOneOfA := c.canotoData.AOneOf.Load()
	if cachedWhichOneOfA == 1 {
		canoto.Append(&w, canoto__OneOfNoCopy__A1__tag)
		canoto.AppendInt(&w, c.A1)
	}
	cachedWhichOneOfB := c.canotoData.BOneOf.Load()
	switch cachedWhichOneOfB {
	case canoto__OneOfNoCopy__B1:
		canoto.Append(&w, canoto__OneOfNoCopy__B1__tag)
		canoto.AppendInt(&w, c.B1)
	case canoto__OneOfNoCopy__B2:
		canoto.Append(&w, canoto__OneOfNoCopy__B2__tag)
		canoto.AppendInt(&w, c.B2)
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__OneOfNoCopy__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	if !canoto.IsZero(c.D) {
		canoto.Append(&w, canoto__OneOfNoCopy__D__tag)
		canoto.AppendInt(&w, c.D)
	}
	if cachedWhichOneOfA == 7 {
		canoto.Append(&w, canoto__OneOfNoCopy__A2__tag)
		canoto.AppendInt(&w, c.A2)
	}
	return w
}

const (
	canoto__Node__Value = 1
	canoto__Node__Next  = 2

	canoto__Node__Value__tag = "\x08" // canoto.Tag(canoto__Node__Value, canoto.Varint)
	canoto__Node__Next__tag  = "\x12" // canoto.Tag(canoto__Node__Next, canoto.Len)
)

type canotoData_Node struct {
	size uint64

	OneOfOneOf uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*Node) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Node{}))
	var zero Node
	s := &canoto.Spec{
		Name: "Node",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__Node__Value,
				Name:        "Value",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Value),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ canoto__Node__Next,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "OneOf",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Node) MakeCanoto() *Node {
	return new(Node)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Node) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Node) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Node{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__Node__Value:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Value); err != nil {
				return err
			}
			if canoto.IsZero(c.Value) {
				return canoto.ErrZeroValue
			}
		case canoto__Node__Next:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.OneOfOneOf, 2) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Node) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var OneOfOneOf uint32
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if (c.Next).CachedCanotoSize() != 0 {
			if OneOfOneOf != 0 {
				return false
			}
			OneOfOneOf = canoto__Node__Next
		}
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *Node) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	var OneOfOneOf uint32
	if !canoto.IsZero(c.Value) {
		size += uint64(len(canoto__Node__Value__tag)) + canoto.SizeInt(c.Value)
	}
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__Node__Next__tag)) + canoto.SizeUint(fieldSize) + fieldSize
			OneOfOneOf = 2
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
	atomic.StoreUint32(&c.canotoData.OneOfOneOf, OneOfOneOf)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Node) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// CachedWhichOneOfOneOf returns the previously calculated field number used
// to represent OneOf.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *Node) CachedWhichOneOfOneOf() uint32 {
	return atomic.LoadUint32(&c.canotoData.OneOfOneOf)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *Node) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *Node) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Value) {
		canoto.Append(&w, canoto__Node__Value__tag)
		canoto.AppendInt(&w, c.Value)
	}
	cachedWhichOneOfOneOf := atomic.LoadUint32(&c.canotoData.OneOfOneOf)
	if cachedWhichOneOfOneOf == 2 {
		fieldSize := (c.Next).CachedCanotoSize()
		canoto.Append(&w, canoto__Node__Next__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (c.Next).MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__RecursiveA__Next = 1

	canoto__RecursiveA__Next__tag = "\x0a" // canoto.Tag(canoto__RecursiveA__Next, canoto.Len)
)

type canotoData_RecursiveA struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*RecursiveA) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(RecursiveA{}))
	var zero RecursiveA
	s := &canoto.Spec{
		Name: "RecursiveA",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ canoto__RecursiveA__Next,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*RecursiveA) MakeCanoto() *RecursiveA {
	return new(RecursiveA)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *RecursiveA) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *RecursiveA) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = RecursiveA{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__RecursiveA__Next:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *RecursiveA) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *RecursiveA) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__RecursiveA__Next__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *RecursiveA) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *RecursiveA) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *RecursiveA) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__RecursiveA__Next__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__RecursiveB__Next = 1

	canoto__RecursiveB__Next__tag = "\x0a" // canoto.Tag(canoto__RecursiveB__Next, canoto.Len)
)

type canotoData_RecursiveB struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*RecursiveB) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(RecursiveB{}))
	var zero RecursiveB
	s := &canoto.Spec{
		Name: "RecursiveB",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ canoto__RecursiveB__Next,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*RecursiveB) MakeCanoto() *RecursiveB {
	return new(RecursiveB)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *RecursiveB) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *RecursiveB) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = RecursiveB{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__RecursiveB__Next:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *RecursiveB) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *RecursiveB) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__RecursiveB__Next__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *RecursiveB) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *RecursiveB) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *RecursiveB) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__RecursiveB__Next__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__GenericField__Value                = 1
	canoto__GenericField__RepeatedValue        = 2
	canoto__GenericField__FixedRepeatedValue   = 3
	canoto__GenericField__Pointer              = 4
	canoto__GenericField__RepeatedPointer      = 5
	canoto__GenericField__FixedRepeatedPointer = 6
	canoto__GenericField__Field                = 7
	canoto__GenericField__RepeatedField        = 8
	canoto__GenericField__FixedRepeatedField   = 9

	canoto__GenericField__Value__tag                = "\x0a" // canoto.Tag(canoto__GenericField__Value, canoto.Len)
	canoto__GenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(canoto__GenericField__RepeatedValue, canoto.Len)
	canoto__GenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(canoto__GenericField__FixedRepeatedValue, canoto.Len)
	canoto__GenericField__Pointer__tag              = "\x22" // canoto.Tag(canoto__GenericField__Pointer, canoto.Len)
	canoto__GenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(canoto__GenericField__RepeatedPointer, canoto.Len)
	canoto__GenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(canoto__GenericField__FixedRepeatedPointer, canoto.Len)
	canoto__GenericField__Field__tag                = "\x3a" // canoto.Tag(canoto__GenericField__Field, canoto.Len)
	canoto__GenericField__RepeatedField__tag        = "\x42" // canoto.Tag(canoto__GenericField__RepeatedField, canoto.Len)
	canoto__GenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(canoto__GenericField__FixedRepeatedField, canoto.Len)
)

type canotoData_GenericField struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*GenericField[T1, T2, T3]) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(GenericField[T1, T2, T3]{}))
	var zero GenericField[T1, T2, T3]
	s := &canoto.Spec{
		Name: "GenericField",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(&zero.Value),
				/*FieldNumber:   */ canoto__GenericField__Value,
				/*Name:          */ "Value",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntryNilPointer(zero.RepeatedValue)),
				/*FieldNumber:   */ canoto__GenericField__RepeatedValue,
				/*Name:          */ "RepeatedValue",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntryNilPointer(zero.FixedRepeatedValue[:])),
				/*FieldNumber:   */ canoto__GenericField__FixedRepeatedValue,
				/*Name:          */ "FixedRepeatedValue",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedValue)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(zero.Pointer),
				/*FieldNumber:   */ canoto__GenericField__Pointer,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ canoto__GenericField__RepeatedPointer,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ canoto__GenericField__FixedRepeatedPointer,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ canoto__GenericField__Field,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ canoto__GenericField__RepeatedField,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ canoto__GenericField__FixedRepeatedField,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*GenericField[T1, T2, T3]) MakeCanoto() *GenericField[T1, T2, T3] {
	return new(GenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *GenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *GenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = GenericField[T1, T2, T3]{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__GenericField__Value:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := T2(&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__GenericField__RepeatedValue:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			field := c.RepeatedValue
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__GenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__GenericField__FixedRepeatedValue:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedValue) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedValue[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__GenericField__Pointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := T2(c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__GenericField__RepeatedPointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			field := c.RepeatedPointer
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = canoto.MakePointer(field[0])
				if err := T2(field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__GenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = canoto.MakePointer(additionalField[i])
				if err := T2(additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__GenericField__FixedRepeatedPointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedPointer) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := T2(c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedPointer[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = canoto.MakePointer(field[i])
				if err := T2(field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__GenericField__Field:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__GenericField__RepeatedField:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			field := c.RepeatedField
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = field[0].MakeCanoto()
				if err := field[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__GenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = additionalField[i].MakeCanoto()
				if err := additionalField[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__GenericField__FixedRepeatedField:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedField) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedField[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = field[i].MakeCanoto()
				if err := field[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *GenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !T2(&c.Value).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedValue
		for i := range field {
			if !T2(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !T2(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !T2(c.Pointer).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			if field[i] != nil && !T2(field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !T2((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedField
		for i := range field {
			if !field[i].ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *GenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	T2(&c.Value).CalculateCanotoCache()
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__GenericField__Value__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedValue
		for i := range field {
			T2(&field[i]).CalculateCanotoCache()
			fieldSize := T2(&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__GenericField__RepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedValue
		)
		for i := range field {
			T2(&field[i]).CalculateCanotoCache()
			fieldSize := T2(&field[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__GenericField__FixedRepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if c.Pointer != nil {
		T2(c.Pointer).CalculateCanotoCache()
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__GenericField__Pointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				T2(field[i]).CalculateCanotoCache()
				fieldSize = T2(field[i]).CachedCanotoSize()
			}
			size += uint64(len(canoto__GenericField__RepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedPointer
		)
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				T2(field[i]).CalculateCanotoCache()
				fieldSize = T2(field[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += uint64(len(canoto__GenericField__FixedRepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__GenericField__Field__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedField
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			size += uint64(len(canoto__GenericField__RepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedField
		)
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__GenericField__FixedRepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *GenericField[T1, T2, T3]) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *GenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *GenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Value__tag)
		canoto.AppendUint(&w, fieldSize)
		w = T2(&c.Value).MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedValue
		for i := range field {
			canoto.Append(&w, canoto__GenericField__RepeatedValue__tag)
			canoto.AppendUint(&w, T2(&field[i]).CachedCanotoSize())
			w = T2(&field[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		field := &c.FixedRepeatedValue
		for i := range field {
			if T2(&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedValue__tag)
				canoto.AppendUint(&w, T2(&field[i]).CachedCanotoSize())
				w = T2(&field[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__GenericField__Pointer__tag)
			canoto.AppendUint(&w, fieldSize)
			w = T2(c.Pointer).MarshalCanotoInto(w)
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			canoto.Append(&w, canoto__GenericField__RepeatedPointer__tag)
			var fieldSize uint64
			if field[i] != nil {
				fieldSize = T2(field[i]).CachedCanotoSize()
			}
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = T2(field[i]).MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedPointer
		for i := range field {
			if field[i] != nil && T2(field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedPointer__tag)
				var fieldSize uint64
				if field[i] != nil {
					fieldSize = T2(field[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = T2(field[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Field__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.Field.MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedField
		for i := range field {
			canoto.Append(&w, canoto__GenericField__RepeatedField__tag)
			fieldSize := field[i].CachedCanotoSize()
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = field[i].MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedField
		for i := range field {
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedField__tag)
				fieldSize := field[i].CachedCanotoSize()
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = field[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__NestedGenericField__Value                = 1
	canoto__NestedGenericField__RepeatedValue        = 2
	canoto__NestedGenericField__FixedRepeatedValue   = 3
	canoto__NestedGenericField__Pointer              = 4
	canoto__NestedGenericField__RepeatedPointer      = 5
	canoto__NestedGenericField__FixedRepeatedPointer = 6
	canoto__NestedGenericField__Field                = 7
	canoto__NestedGenericField__RepeatedField        = 8
	canoto__NestedGenericField__FixedRepeatedField   = 9

	canoto__NestedGenericField__Value__tag                = "\x0a" // canoto.Tag(canoto__NestedGenericField__Value, canoto.Len)
	canoto__NestedGenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(canoto__NestedGenericField__RepeatedValue, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(canoto__NestedGenericField__FixedRepeatedValue, canoto.Len)
	canoto__NestedGenericField__Pointer__tag              = "\x22" // canoto.Tag(canoto__NestedGenericField__Pointer, canoto.Len)
	canoto__NestedGenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(canoto__NestedGenericField__RepeatedPointer, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(canoto__NestedGenericField__FixedRepeatedPointer, canoto.Len)
	canoto__NestedGenericField__Field__tag                = "\x3a" // canoto.Tag(canoto__NestedGenericField__Field, canoto.Len)
	canoto__NestedGenericField__RepeatedField__tag        = "\x42" // canoto.Tag(canoto__NestedGenericField__RepeatedField, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(canoto__NestedGenericField__FixedRepeatedField, canoto.Len)
)

type canotoData_NestedGenericField struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*NestedGenericField[T1, T2, T3]) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(NestedGenericField[T1, T2, T3]{}))
	var zero NestedGenericField[T1, T2, T3]
	s := &canoto.Spec{
		Name: "NestedGenericField",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.Value),
				/*FieldNumber:   */ canoto__NestedGenericField__Value,
				/*Name:          */ "Value",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.RepeatedValue)),
				/*FieldNumber:   */ canoto__NestedGenericField__RepeatedValue,
				/*Name:          */ "RepeatedValue",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.FixedRepeatedValue[:])),
				/*FieldNumber:   */ canoto__NestedGenericField__FixedRepeatedValue,
				/*Name:          */ "FixedRepeatedValue",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedValue)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Pointer),
				/*FieldNumber:   */ canoto__NestedGenericField__Pointer,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ canoto__NestedGenericField__RepeatedPointer,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ canoto__NestedGenericField__FixedRepeatedPointer,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ canoto__NestedGenericField__Field,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ canoto__NestedGenericField__RepeatedField,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ canoto__NestedGenericField__FixedRepeatedField,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*NestedGenericField[T1, T2, T3]) MakeCanoto() *NestedGenericField[T1, T2, T3] {
	return new(NestedGenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = NestedGenericField[T1, T2, T3]{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__NestedGenericField__Value:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__NestedGenericField__RepeatedValue:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			field := c.RepeatedValue
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__NestedGenericField__FixedRepeatedValue:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedValue) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedValue[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__NestedGenericField__Pointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__NestedGenericField__RepeatedPointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			field := c.RepeatedPointer
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = canoto.MakePointer(field[0])
				if err := (field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = canoto.MakePointer(additionalField[i])
				if err := (additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__NestedGenericField__FixedRepeatedPointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedPointer) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedPointer[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = canoto.MakePointer(field[i])
				if err := (field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__NestedGenericField__Field:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__NestedGenericField__RepeatedField:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			field := c.RepeatedField
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = field[0].MakeCanoto()
				if err := field[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = additionalField[i].MakeCanoto()
				if err := additionalField[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__NestedGenericField__FixedRepeatedField:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedField) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedField[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = field[i].MakeCanoto()
				if err := field[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Value).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedValue
		for i := range field {
			if !(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			if field[i] != nil && !(field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedField
		for i := range field {
			if !field[i].ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *NestedGenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	(&c.Value).CalculateCanotoCache()
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__NestedGenericField__Value__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedValue
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__NestedGenericField__RepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedValue
		)
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__NestedGenericField__FixedRepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__NestedGenericField__Pointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
			}
			size += uint64(len(canoto__NestedGenericField__RepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedPointer
		)
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += uint64(len(canoto__NestedGenericField__FixedRepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__NestedGenericField__Field__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedField
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			size += uint64(len(canoto__NestedGenericField__RepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedField
		)
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__NestedGenericField__FixedRepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *NestedGenericField[T1, T2, T3]) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Value__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.Value).MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedValue
		for i := range field {
			canoto.Append(&w, canoto__NestedGenericField__RepeatedValue__tag)
			canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
			w = (&field[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		field := &c.FixedRepeatedValue
		for i := range field {
			if (&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedValue__tag)
				canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
				w = (&field[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__NestedGenericField__Pointer__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			canoto.Append(&w, canoto__NestedGenericField__RepeatedPointer__tag)
			var fieldSize uint64
			if field[i] != nil {
				fieldSize = (field[i]).CachedCanotoSize()
			}
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = (field[i]).MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedPointer
		for i := range field {
			if field[i] != nil && (field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedPointer__tag)
				var fieldSize uint64
				if field[i] != nil {
					fieldSize = (field[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = (field[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Field__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.Field.MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedField
		for i := range field {
			canoto.Append(&w, canoto__NestedGenericField__RepeatedField__tag)
			fieldSize := field[i].CachedCanotoSize()
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = field[i].MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedField
		for i := range field {
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedField__tag)
				fieldSize := field[i].CachedCanotoSize()
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = field[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__Embedded__OneOf              = 1
	canoto__Embedded__LargestFieldNumber = 2
	canoto__Embedded__GenericField       = 3
	canoto__Embedded__Int                = 4

	canoto__Embedded__OneOf__tag              = "\x0a" // canoto.Tag(canoto__Embedded__OneOf, canoto.Len)
	canoto__Embedded__LargestFieldNumber__tag = "\x12" // canoto.Tag(canoto__Embedded__LargestFieldNumber, canoto.Len)
	canoto__Embedded__GenericField__tag       = "\x1a" // canoto.Tag(canoto__Embedded__GenericField, canoto.Len)
	canoto__Embedded__Int__tag                = "\x22" // canoto.Tag(canoto__Embedded__Int, canoto.Len)
)

type canotoData_Embedded struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*Embedded) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Embedded{}))
	var zero Embedded
	s := &canoto.Spec{
		Name: "Embedded",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.OneOf),
				/*FieldNumber:   */ canoto__Embedded__OneOf,
				/*Name:          */ "OneOf",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.LargestFieldNumber),
				/*FieldNumber:   */ canoto__Embedded__LargestFieldNumber,
				/*Name:          */ "LargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.GenericField,
				/*FieldNumber:   */ canoto__Embedded__GenericField,
				/*Name:          */ "GenericField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Int),
				/*FieldNumber:   */ canoto__Embedded__Int,
				/*Name:          */ "Int",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Embedded) MakeCanoto() *Embedded {
	return new(Embedded)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Embedded) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Embedded) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Embedded{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__Embedded__OneOf:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Embedded__LargestFieldNumber:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.LargestFieldNumber = canoto.MakePointer(c.LargestFieldNumber)
			if err := (c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Embedded__GenericField:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.GenericField = c.GenericField.MakeCanoto()
			if err := c.GenericField.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Embedded__Int:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Int = canoto.MakePointer(c.Int)
			if err := (c.Int).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Embedded) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.LargestFieldNumber != nil && !(c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	if !c.GenericField.ValidCanoto() {
		return false
	}
	if c.Int != nil && !(c.Int).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *Embedded) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Embedded__OneOf__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if c.LargestFieldNumber != nil {
		(c.LargestFieldNumber).CalculateCanotoCache()
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__Embedded__LargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	c.GenericField.CalculateCanotoCache()
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Embedded__GenericField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if c.Int != nil {
		(c.Int).CalculateCanotoCache()
		if fieldSize := (c.Int).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__Embedded__Int__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Embedded) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *Embedded) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *Embedded) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__OneOf__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.LargestFieldNumber != nil {
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Embedded__LargestFieldNumber__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.LargestFieldNumber).MarshalCanotoInto(w)
		}
	}
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__GenericField__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.GenericField.MarshalCanotoInto(w)
	}
	if c.Int != nil {
		if fieldSize := (c.Int).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Embedded__Int__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Int).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__A__B_1_1C = 1

	canoto__A__B_1_1C__tag = "\x08" // canoto.Tag(canoto__A__B_1_1C, canoto.Varint)
)

type canotoData_A struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*A) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero A
	s := &canoto.Spec{
		Name: "A",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__A__B_1_1C,
				Name:        "B__C",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.B__C),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*A) MakeCanoto() *A {
	return new(A)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__A__B_1_1C:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.B__C); err != nil {
				return err
			}
			if canoto.IsZero(c.B__C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *A) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.B__C) {
		size += uint64(len(canoto__A__B_1_1C__tag)) + canoto.SizeInt(c.B__C)
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *A) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *A) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.B__C) {
		canoto.Append(&w, canoto__A__B_1_1C__tag)
		canoto.AppendInt(&w, c.B__C)
	}
	return w
}

const (
	canoto__A_1_1B__C = 1

	canoto__A_1_1B__C__tag = "\x08" // canoto.Tag(canoto__A_1_1B__C, canoto.Varint)
)

type canotoData_A__B struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*A__B) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero A__B
	s := &canoto.Spec{
		Name: "A__B",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__A_1_1B__C,
				Name:        "C",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.C),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*A__B) MakeCanoto() *A__B {
	return new(A__B)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A__B) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A__B) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A__B{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__A_1_1B__C:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A__B) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *A__B) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.C) {
		size += uint64(len(canoto__A_1_1B__C__tag)) + canoto.SizeInt(c.C)
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A__B) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *A__B) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *A__B) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__A_1_1B__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	return w
}

const (
	canoto__Scalars__Int8                            = 1
	canoto__Scalars__Int16                           = 2
	canoto__Scalars__Int32                           = 3
	canoto__Scalars__Int64                           = 4
	canoto__Scalars__Uint8                           = 5
	canoto__Scalars__Uint16                          = 6
	canoto__Scalars__Uint32                          = 7
	canoto__Scalars__Uint64                          = 8
	canoto__Scalars__Sfixed32                        = 9
	canoto__Scalars__Fixed32                         = 10
	canoto__Scalars__Sfixed64                        = 11
	canoto__Scalars__Fixed64                         = 12
	canoto__Scalars__Bool                            = 13
	canoto__Scalars__String                          = 14
	canoto__Scalars__Bytes                           = 15
	canoto__Scalars__LargestFieldNumber              = 16
	canoto__Scalars__RepeatedInt8                    = 17
	canoto__Scalars__RepeatedInt16                   = 18
	canoto__Scalars__RepeatedInt32                   = 19
	canoto__Scalars__RepeatedInt64                   = 20
	canoto__Scalars__RepeatedUint8                   = 21
	canoto__Scalars__RepeatedUint16                  = 22
	canoto__Scalars__RepeatedUint32                  = 23
	canoto__Scalars__RepeatedUint64                  = 24
	canoto__Scalars__RepeatedSfixed32                = 25
	canoto__Scalars__RepeatedFixed32                 = 26
	canoto__Scalars__RepeatedSfixed64                = 27
	canoto__Scalars__RepeatedFixed64                 = 28
	canoto__Scalars__RepeatedBool                    = 29
	canoto__Scalars__RepeatedString                  = 30
	canoto__Scalars__RepeatedBytes                   = 31
	canoto__Scalars__RepeatedLargestFieldNumber      = 32
	canoto__Scalars__FixedRepeatedInt8               = 33
	canoto__Scalars__FixedRepeatedInt16              = 34
	canoto__Scalars__FixedRepeatedInt32              = 35
	canoto__Scalars__FixedRepeatedInt64              = 36
	canoto__Scalars__FixedRepeatedUint8              = 37
	canoto__Scalars__FixedRepeatedUint16             = 38
	canoto__Scalars__FixedRepeatedUint32             = 39
	canoto__Scalars__FixedRepeatedUint64             = 40
	canoto__Scalars__FixedRepeatedSfixed32           = 41
	canoto__Scalars__FixedRepeatedFixed32            = 42
	canoto__Scalars__FixedRepeatedSfixed64           = 43
	canoto__Scalars__FixedRepeatedFixed64            = 44
	canoto__Scalars__FixedRepeatedBool               = 45
	canoto__Scalars__FixedRepeatedString             = 46
	canoto__Scalars__FixedBytes                      = 47
	canoto__Scalars__RepeatedFixedBytes              = 48
	canoto__Scalars__FixedRepeatedBytes              = 49
	canoto__Scalars__FixedRepeatedFixedBytes         = 50
	canoto__Scalars__FixedRepeatedLargestFieldNumber = 51
	canoto__Scalars__ConstRepeatedUint64             = 52
	canoto__Scalars__CustomType                      = 53
	canoto__Scalars__CustomUint32                    = 54
	canoto__Scalars__CustomString                    = 55
	canoto__Scalars__CustomBytes                     = 56
	canoto__Scalars__CustomFixedBytes                = 57
	canoto__Scalars__CustomRepeatedBytes             = 58
	canoto__Scalars__CustomRepeatedFixedBytes        = 59
	canoto__Scalars__CustomFixedRepeatedBytes        = 60
	canoto__Scalars__CustomFixedRepeatedFixedBytes   = 61
	canoto__Scalars__OneOf                           = 62
	canoto__Scalars__Pointer                         = 63
	canoto__Scalars__RepeatedPointer                 = 64
	canoto__Scalars__FixedRepeatedPointer            = 65
	canoto__Scalars__Field                           = 66
	canoto__Scalars__RepeatedField                   = 67
	canoto__Scalars__FixedRepeatedField              = 68

	canoto__Scalars__Int8__tag                            = "\x08"     // canoto.Tag(canoto__Scalars__Int8, canoto.Varint)
	canoto__Scalars__Int16__tag                           = "\x10"     // canoto.Tag(canoto__Scalars__Int16, canoto.Varint)
	canoto__Scalars__Int32__tag                           = "\x18"     // canoto.Tag(canoto__Scalars__Int32, canoto.Varint)
	canoto__Scalars__Int64__tag                           = "\x20"     // canoto.Tag(canoto__Scalars__Int64, canoto.Varint)
	canoto__Scalars__Uint8__tag                           = "\x28"     // canoto.Tag(canoto__Scalars__Uint8, canoto.Varint)
	canoto__Scalars__Uint16__tag                          = "\x30"     // canoto.Tag(canoto__Scalars__Uint16, canoto.Varint)
	canoto__Scalars__Uint32__tag                          = "\x38"     // canoto.Tag(canoto__Scalars__Uint32, canoto.Varint)
	canoto__Scalars__Uint64__tag                          = "\x40"     // canoto.Tag(canoto__Scalars__Uint64, canoto.Varint)
	canoto__Scalars__Sfixed32__tag                        = "\x4d"     // canoto.Tag(canoto__Scalars__Sfixed32, canoto.I32)
	canoto__Scalars__Fixed32__tag                         = "\x55"     // canoto.Tag(canoto__Scalars__Fixed32, canoto.I32)
	canoto__Scalars__Sfixed64__tag                        = "\x59"     // canoto.Tag(canoto__Scalars__Sfixed64, canoto.I64)
	canoto__Scalars__Fixed64__tag                         = "\x61"     // canoto.Tag(canoto__Scalars__Fixed64, canoto.I64)
	canoto__Scalars__Bool__tag                            = "\x68"     // canoto.Tag(canoto__Scalars__Bool, canoto.Varint)
	canoto__Scalars__String__tag                          = "\x72"     // canoto.Tag(canoto__Scalars__String, canoto.Len)
	canoto__Scalars__Bytes__tag                           = "\x7a"     // canoto.Tag(canoto__Scalars__Bytes, canoto.Len)
	canoto__Scalars__LargestFieldNumber__tag              = "\x82\x01" // canoto.Tag(canoto__Scalars__LargestFieldNumber, canoto.Len)
	canoto__Scalars__RepeatedInt8__tag                    = "\x8a\x01" // canoto.Tag(canoto__Scalars__RepeatedInt8, canoto.Len)
	canoto__Scalars__RepeatedInt16__tag                   = "\x92\x01" // canoto.Tag(canoto__Scalars__RepeatedInt16, canoto.Len)
	canoto__Scalars__RepeatedInt32__tag                   = "\x9a\x01" // canoto.Tag(canoto__Scalars__RepeatedInt32, canoto.Len)
	canoto__Scalars__RepeatedInt64__tag                   = "\xa2\x01" // canoto.Tag(canoto__Scalars__RepeatedInt64, canoto.Len)
	canoto__Scalars__RepeatedUint8__tag                   = "\xaa\x01" // canoto.Tag(canoto__Scalars__RepeatedUint8, canoto.Len)
	canoto__Scalars__RepeatedUint16__tag                  = "\xb2\x01" // canoto.Tag(canoto__Scalars__RepeatedUint16, canoto.Len)
	canoto__Scalars__RepeatedUint32__tag                  = "\xba\x01" // canoto.Tag(canoto__Scalars__RepeatedUint32, canoto.Len)
	canoto__Scalars__RepeatedUint64__tag                  = "\xc2\x01" // canoto.Tag(canoto__Scalars__RepeatedUint64, canoto.Len)
	canoto__Scalars__RepeatedSfixed32__tag                = "\xca\x01" // canoto.Tag(canoto__Scalars__RepeatedSfixed32, canoto.Len)
	canoto__Scalars__RepeatedFixed32__tag                 = "\xd2\x01" // canoto.Tag(canoto__Scalars__RepeatedFixed32, canoto.Len)
	canoto__Scalars__RepeatedSfixed64__tag                = "\xda\x01" // canoto.Tag(canoto__Scalars__RepeatedSfixed64, canoto.Len)
	canoto__Scalars__RepeatedFixed64__tag                 = "\xe2\x01" // canoto.Tag(canoto__Scalars__RepeatedFixed64, canoto.Len)
	canoto__Scalars__RepeatedBool__tag                    = "\xea\x01" // canoto.Tag(canoto__Scalars__RepeatedBool, canoto.Len)
	canoto__Scalars__RepeatedString__tag                  = "\xf2\x01" // canoto.Tag(canoto__Scalars__RepeatedString, canoto.Len)
	canoto__Scalars__RepeatedBytes__tag                   = "\xfa\x01" // canoto.Tag(canoto__Scalars__RepeatedBytes, canoto.Len)
	canoto__Scalars__RepeatedLargestFieldNumber__tag      = "\x82\x02" // canoto.Tag(canoto__Scalars__RepeatedLargestFieldNumber, canoto.Len)
	canoto__Scalars__FixedRepeatedInt8__tag               = "\x8a\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedInt8, canoto.Len)
	canoto__Scalars__FixedRepeatedInt16__tag              = "\x92\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedInt16, canoto.Len)
	canoto__Scalars__FixedRepeatedInt32__tag              = "\x9a\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedInt32, canoto.Len)
	canoto__Scalars__FixedRepeatedInt64__tag              = "\xa2\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedInt64, canoto.Len)
	canoto__Scalars__FixedRepeatedUint8__tag              = "\xaa\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedUint8, canoto.Len)
	canoto__Scalars__FixedRepeatedUint16__tag             = "\xb2\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedUint16, canoto.Len)
	canoto__Scalars__FixedRepeatedUint32__tag             = "\xba\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedUint32, canoto.Len)
	canoto__Scalars__FixedRepeatedUint64__tag             = "\xc2\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedUint64, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed32__tag           = "\xca\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedSfixed32, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed32__tag            = "\xd2\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedFixed32, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed64__tag           = "\xda\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedSfixed64, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed64__tag            = "\xe2\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedFixed64, canoto.Len)
	canoto__Scalars__FixedRepeatedBool__tag               = "\xea\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedBool, canoto.Len)
	canoto__Scalars__FixedRepeatedString__tag             = "\xf2\x02" // canoto.Tag(canoto__Scalars__FixedRepeatedString, canoto.Len)
	canoto__Scalars__FixedBytes__tag                      = "\xfa\x02" // canoto.Tag(canoto__Scalars__FixedBytes, canoto.Len)
	canoto__Scalars__RepeatedFixedBytes__tag              = "\x82\x03" // canoto.Tag(canoto__Scalars__RepeatedFixedBytes, canoto.Len)
	canoto__Scalars__FixedRepeatedBytes__tag              = "\x8a\x03" // canoto.Tag(canoto__Scalars__FixedRepeatedBytes, canoto.Len)
	canoto__Scalars__FixedRepeatedFixedBytes__tag         = "\x92\x03" // canoto.Tag(canoto__Scalars__FixedRepeatedFixedBytes, canoto.Len)
	canoto__Scalars__FixedRepeatedLargestFieldNumber__tag = "\x9a\x03" // canoto.Tag(canoto__Scalars__FixedRepeatedLargestFieldNumber, canoto.Len)
	canoto__Scalars__ConstRepeatedUint64__tag             = "\xa2\x03" // canoto.Tag(canoto__Scalars__ConstRepeatedUint64, canoto.Len)
	canoto__Scalars__CustomType__tag                      = "\xaa\x03" // canoto.Tag(canoto__Scalars__CustomType, canoto.Len)
	canoto__Scalars__CustomUint32__tag                    = "\xb5\x03" // canoto.Tag(canoto__Scalars__CustomUint32, canoto.I32)
	canoto__Scalars__CustomString__tag                    = "\xba\x03" // canoto.Tag(canoto__Scalars__CustomString, canoto.Len)
	canoto__Scalars__CustomBytes__tag                     = "\xc2\x03" // canoto.Tag(canoto__Scalars__CustomBytes, canoto.Len)
	canoto__Scalars__CustomFixedBytes__tag                = "\xca\x03" // canoto.Tag(canoto__Scalars__CustomFixedBytes, canoto.Len)
	canoto__Scalars__CustomRepeatedBytes__tag             = "\xd2\x03" // canoto.Tag(canoto__Scalars__CustomRepeatedBytes, canoto.Len)
	canoto__Scalars__CustomRepeatedFixedBytes__tag        = "\xda\x03" // canoto.Tag(canoto__Scalars__CustomRepeatedFixedBytes, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedBytes__tag        = "\xe2\x03" // canoto.Tag(canoto__Scalars__CustomFixedRepeatedBytes, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedFixedBytes__tag   = "\xea\x03" // canoto.Tag(canoto__Scalars__CustomFixedRepeatedFixedBytes, canoto.Len)
	canoto__Scalars__OneOf__tag                           = "\xf2\x03" // canoto.Tag(canoto__Scalars__OneOf, canoto.Len)
	canoto__Scalars__Pointer__tag                         = "\xfa\x03" // canoto.Tag(canoto__Scalars__Pointer, canoto.Len)
	canoto__Scalars__RepeatedPointer__tag                 = "\x82\x04" // canoto.Tag(canoto__Scalars__RepeatedPointer, canoto.Len)
	canoto__Scalars__FixedRepeatedPointer__tag            = "\x8a\x04" // canoto.Tag(canoto__Scalars__FixedRepeatedPointer, canoto.Len)
	canoto__Scalars__Field__tag                           = "\x92\x04" // canoto.Tag(canoto__Scalars__Field, canoto.Len)
	canoto__Scalars__RepeatedField__tag                   = "\x9a\x04" // canoto.Tag(canoto__Scalars__RepeatedField, canoto.Len)
	canoto__Scalars__FixedRepeatedField__tag              = "\xa2\x04" // canoto.Tag(canoto__Scalars__FixedRepeatedField, canoto.Len)
)

type canotoData_Scalars struct {
	size                    uint64
	RepeatedInt8Size        uint64
	RepeatedInt16Size       uint64
	RepeatedInt32Size       uint64
	RepeatedInt64Size       uint64
	RepeatedUint8Size       uint64
	RepeatedUint16Size      uint64
	RepeatedUint32Size      uint64
	RepeatedUint64Size      uint64
	FixedRepeatedInt8Size   uint64
	FixedRepeatedInt16Size  uint64
	FixedRepeatedInt32Size  uint64
	FixedRepeatedInt64Size  uint64
	FixedRepeatedUint8Size  uint64
	FixedRepeatedUint16Size uint64
	FixedRepeatedUint32Size uint64
	FixedRepeatedUint64Size uint64
	ConstRepeatedUint64Size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*Scalars) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Scalars{}))
	var zero Scalars
	s := &canoto.Spec{
		Name: "Scalars",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__Scalars__Int8,
				Name:        "Int8",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int8),
			},
			{
				FieldNumber: canoto__Scalars__Int16,
				Name:        "Int16",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int16),
			},
			{
				FieldNumber: canoto__Scalars__Int32,
				Name:        "Int32",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int32),
			},
			{
				FieldNumber: canoto__Scalars__Int64,
				Name:        "Int64",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int64),
			},
			{
				FieldNumber: canoto__Scalars__Uint8,
				Name:        "Uint8",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint8),
			},
			{
				FieldNumber: canoto__Scalars__Uint16,
				Name:        "Uint16",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint16),
			},
			{
				FieldNumber: canoto__Scalars__Uint32,
				Name:        "Uint32",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint32),
			},
			{
				FieldNumber: canoto__Scalars__Uint64,
				Name:        "Uint64",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint64),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed32,
				/*FieldNumber:   */ canoto__Scalars__Sfixed32,
				/*Name:          */ "Sfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Fixed32,
				/*FieldNumber:   */ canoto__Scalars__Fixed32,
				/*Name:          */ "Fixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed64,
				/*FieldNumber:   */ canoto__Scalars__Sfixed64,
				/*Name:          */ "Sfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Fixed64,
				/*FieldNumber:   */ canoto__Scalars__Fixed64,
				/*Name:          */ "Fixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: canoto__Scalars__Bool,
				Name:        "Bool",
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: canoto__Scalars__String,
				Name:        "String",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: canoto__Scalars__Bytes,
				Name:        "Bytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.LargestFieldNumber),
				/*FieldNumber:   */ canoto__Scalars__LargestFieldNumber,
				/*Name:          */ "LargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: canoto__Scalars__RepeatedInt8,
				Name:        "RepeatedInt8",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt8)),
			},
			{
				FieldNumber: canoto__Scalars__RepeatedInt16,
				Name:        "RepeatedInt16",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt16)),
			},
			{
				FieldNumber: canoto__Scalars__RepeatedInt32,
				Name:        "RepeatedInt32",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt32)),
			},
			{
				FieldNumber: canoto__Scalars__RepeatedInt64,
				Name:        "RepeatedInt64",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt64)),
			},
			{
				FieldNumber: canoto__Scalars__RepeatedUint8,
				Name:        "RepeatedUint8",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint8)),
			},
			{
				FieldNumber: canoto__Scalars__RepeatedUint16,
				Name:        "RepeatedUint16",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint16)),
			},
			{
				FieldNumber: canoto__Scalars__RepeatedUint32,
				Name:        "RepeatedUint32",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint32)),
			},
			{
				FieldNumber: canoto__Scalars__RepeatedUint64,
				Name:        "RepeatedUint64",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint64)),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedSfixed32),
				/*FieldNumber:   */ canoto__Scalars__RepeatedSfixed32,
				/*Name:          */ "RepeatedSfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedFixed32),
				/*FieldNumber:   */ canoto__Scalars__RepeatedFixed32,
				/*Name:          */ "RepeatedFixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedSfixed64),
				/*FieldNumber:   */ canoto__Scalars__RepeatedSfixed64,
				/*Name:          */ "RepeatedSfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedFixed64),
				/*FieldNumber:   */ canoto__Scalars__RepeatedFixed64,
				/*Name:          */ "RepeatedFixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: canoto__Scalars__RepeatedBool,
				Name:        "RepeatedBool",
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: canoto__Scalars__RepeatedString,
				Name:        "RepeatedString",
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: canoto__Scalars__RepeatedBytes,
				Name:        "RepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.RepeatedLargestFieldNumber)),
				/*FieldNumber:   */ canoto__Scalars__RepeatedLargestFieldNumber,
				/*Name:          */ "RepeatedLargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: canoto__Scalars__FixedRepeatedInt8,
				Name:        "FixedRepeatedInt8",
				FixedLength: uint64(len(zero.FixedRepeatedInt8)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt8[:])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedInt16,
				Name:        "FixedRepeatedInt16",
				FixedLength: uint64(len(zero.FixedRepeatedInt16)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt16[:])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedInt32,
				Name:        "FixedRepeatedInt32",
				FixedLength: uint64(len(zero.FixedRepeatedInt32)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt32[:])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedInt64,
				Name:        "FixedRepeatedInt64",
				FixedLength: uint64(len(zero.FixedRepeatedInt64)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt64[:])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedUint8,
				Name:        "FixedRepeatedUint8",
				FixedLength: uint64(len(zero.FixedRepeatedUint8)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint8[:])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedUint16,
				Name:        "FixedRepeatedUint16",
				FixedLength: uint64(len(zero.FixedRepeatedUint16)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint16[:])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedUint32,
				Name:        "FixedRepeatedUint32",
				FixedLength: uint64(len(zero.FixedRepeatedUint32)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint32[:])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedUint64,
				Name:        "FixedRepeatedUint64",
				FixedLength: uint64(len(zero.FixedRepeatedUint64)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint64[:])),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedSfixed32[:]),
				/*FieldNumber:   */ canoto__Scalars__FixedRepeatedSfixed32,
				/*Name:          */ "FixedRepeatedSfixed32",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedSfixed32)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedFixed32[:]),
				/*FieldNumber:   */ canoto__Scalars__FixedRepeatedFixed32,
				/*Name:          */ "FixedRepeatedFixed32",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedFixed32)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedSfixed64[:]),
				/*FieldNumber:   */ canoto__Scalars__FixedRepeatedSfixed64,
				/*Name:          */ "FixedRepeatedSfixed64",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedSfixed64)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedFixed64[:]),
				/*FieldNumber:   */ canoto__Scalars__FixedRepeatedFixed64,
				/*Name:          */ "FixedRepeatedFixed64",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedFixed64)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: canoto__Scalars__FixedRepeatedBool,
				Name:        "FixedRepeatedBool",
				FixedLength: uint64(len(zero.FixedRepeatedBool)),
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedString,
				Name:        "FixedRepeatedString",
				FixedLength: uint64(len(zero.FixedRepeatedString)),
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber:    canoto__Scalars__FixedBytes,
				Name:           "FixedBytes",
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.FixedBytes)),
			},
			{
				FieldNumber:    canoto__Scalars__RepeatedFixedBytes,
				Name:           "RepeatedFixedBytes",
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.RepeatedFixedBytes[0])),
			},
			{
				FieldNumber: canoto__Scalars__FixedRepeatedBytes,
				Name:        "FixedRepeatedBytes",
				FixedLength: uint64(len(zero.FixedRepeatedBytes)),
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    canoto__Scalars__FixedRepeatedFixedBytes,
				Name:           "FixedRepeatedFixedBytes",
				FixedLength:    uint64(len(zero.FixedRepeatedFixedBytes)),
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.FixedRepeatedFixedBytes[0])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.FixedRepeatedLargestFieldNumber[:])),
				/*FieldNumber:   */ canoto__Scalars__FixedRepeatedLargestFieldNumber,
				/*Name:          */ "FixedRepeatedLargestFieldNumber",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedLargestFieldNumber)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: canoto__Scalars__ConstRepeatedUint64,
				Name:        "ConstRepeatedUint64",
				FixedLength: uint64(len(zero.ConstRepeatedUint64)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.ConstRepeatedUint64[:])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.CustomType),
				/*FieldNumber:   */ canoto__Scalars__CustomType,
				/*Name:          */ "CustomType",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.CustomUint32,
				/*FieldNumber:   */ canoto__Scalars__CustomUint32,
				/*Name:          */ "CustomUint32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: canoto__Scalars__CustomString,
				Name:        "CustomString",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: canoto__Scalars__CustomBytes,
				Name:        "CustomBytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    canoto__Scalars__CustomFixedBytes,
				Name:           "CustomFixedBytes",
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomFixedBytes)),
			},
			{
				FieldNumber: canoto__Scalars__CustomRepeatedBytes,
				Name:        "CustomRepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    canoto__Scalars__CustomRepeatedFixedBytes,
				Name:           "CustomRepeatedFixedBytes",
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomRepeatedFixedBytes[0])),
			},
			{
				FieldNumber: canoto__Scalars__CustomFixedRepeatedBytes,
				Name:        "CustomFixedRepeatedBytes",
				FixedLength: uint64(len(zero.CustomFixedRepeatedBytes)),
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    canoto__Scalars__CustomFixedRepeatedFixedBytes,
				Name:           "CustomFixedRepeatedFixedBytes",
				FixedLength:    uint64(len(zero.CustomFixedRepeatedFixedBytes)),
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomFixedRepeatedFixedBytes[0])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.OneOf),
				/*FieldNumber:   */ canoto__Scalars__OneOf,
				/*Name:          */ "OneOf",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Pointer),
				/*FieldNumber:   */ canoto__Scalars__Pointer,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ canoto__Scalars__RepeatedPointer,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ canoto__Scalars__FixedRepeatedPointer,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ canoto__Scalars__Field,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ canoto__Scalars__RepeatedField,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ canoto__Scalars__FixedRepeatedField,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Scalars) MakeCanoto() *Scalars {
	return new(Scalars)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Scalars) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Scalars) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Scalars{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__Scalars__Int8:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int8); err != nil {
				return err
			}
			if canoto.IsZero(c.Int8) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Int16:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int16); err != nil {
				return err
			}
			if canoto.IsZero(c.Int16) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Int32:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int32); err != nil {
				return err
			}
			if canoto.IsZero(c.Int32) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Int64:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int64); err != nil {
				return err
			}
			if canoto.IsZero(c.Int64) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Uint8:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint8); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint8) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Uint16:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint16); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint16) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Uint32:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint32); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint32) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Uint64:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint64); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint64) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Sfixed32:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Sfixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed32) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Fixed32:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Fixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed32) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Sfixed64:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Sfixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed64) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Fixed64:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Fixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed64) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Bool:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBool(&r, &c.Bool); err != nil {
				return err
			}
			if canoto.IsZero(c.Bool) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__String:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.String); err != nil {
				return err
			}
			if len(c.String) == 0 {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Bytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Bytes); err != nil {
				return err
			}
			if len(c.Bytes) == 0 {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__LargestFieldNumber:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedInt8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt8 = canoto.MakeSlice(c.RepeatedInt8, canoto.CountInts(msgBytes))
			field := c.RepeatedInt8
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt8Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedInt16:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt16 = canoto.MakeSlice(c.RepeatedInt16, canoto.CountInts(msgBytes))
			field := c.RepeatedInt16
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt16Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedInt32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt32 = canoto.MakeSlice(c.RepeatedInt32, canoto.CountInts(msgBytes))
			field := c.RepeatedInt32
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt32Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedInt64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt64 = canoto.MakeSlice(c.RepeatedInt64, canoto.CountInts(msgBytes))
			field := c.RepeatedInt64
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt64Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedUint8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint8 = canoto.MakeSlice(c.RepeatedUint8, canoto.CountInts(msgBytes))
			field := c.RepeatedUint8
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedUint8Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedUint16:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint16 = canoto.MakeSlice(c.RepeatedUint16, canoto.CountInts(msgBytes))
			field := c.RepeatedUint16
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedUint16Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedUint32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint32 = canoto.MakeSlice(c.RepeatedUint32, canoto.CountInts(msgBytes))
			field := c.RepeatedUint32
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedUint32Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedUint64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint64 = canoto.MakeSlice(c.RepeatedUint64, canoto.CountInts(msgBytes))
			field := c.RepeatedUint64
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedUint64Size, uint64(len(msgBytes)))
		case canoto__Scalars__RepeatedSfixed32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed32 = canoto.MakeSlice(c.RepeatedSfixed32, numMsgBytes/canoto.SizeFint32)
			field := c.RepeatedSfixed32
			for i := range field {
				if err := canoto.ReadFint32(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedFixed32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed32 = canoto.MakeSlice(c.RepeatedFixed32, numMsgBytes/canoto.SizeFint32)
			field := c.RepeatedFixed32
			for i := range field {
				if err := canoto.ReadFint32(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedSfixed64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed64 = canoto.MakeSlice(c.RepeatedSfixed64, numMsgBytes/canoto.SizeFint64)
			field := c.RepeatedSfixed64
			for i := range field {
				if err := canoto.ReadFint64(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedFixed64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed64 = canoto.MakeSlice(c.RepeatedFixed64, numMsgBytes/canoto.SizeFint64)
			field := c.RepeatedFixed64
			for i := range field {
				if err := canoto.ReadFint64(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedBool:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeBool != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedBool = canoto.MakeSlice(c.RepeatedBool, numMsgBytes/canoto.SizeBool)
			field := c.RepeatedBool
			for i := range field {
				if err := canoto.ReadBool(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedString:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedString__tag)
			if err != nil {
				return err
			}
			c.RepeatedString = canoto.MakeSlice(c.RepeatedString, countMinus1+1)
			field := c.RepeatedString

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadString(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__RepeatedString__tag):]
				if err := canoto.ReadString(&r, &field[i]); err != nil {
					return err
				}
			}
		case canoto__Scalars__RepeatedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.RepeatedBytes = canoto.MakeSlice(c.RepeatedBytes, countMinus1+1)
			field := c.RepeatedBytes

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__RepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
			}
		case canoto__Scalars__RepeatedLargestFieldNumber:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedLargestFieldNumber__tag)
			if err != nil {
				return err
			}

			c.RepeatedLargestFieldNumber = canoto.MakeSlice(c.RepeatedLargestFieldNumber, countMinus1+1)
			field := c.RepeatedLargestFieldNumber
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__Scalars__RepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__Scalars__FixedRepeatedInt8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt8 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedInt8Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedInt16:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt16 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedInt16Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedInt32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt32 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedInt32Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedInt64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt64 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedInt64Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedUint8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint8 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedUint8Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedUint16:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint16 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedUint16Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedUint32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint32 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedUint32Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedUint64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint64 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.FixedRepeatedUint64Size, uint64(len(msgBytes)))
		case canoto__Scalars__FixedRepeatedSfixed32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedSfixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedSfixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case canoto__Scalars__FixedRepeatedFixed32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedFixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedFixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case canoto__Scalars__FixedRepeatedSfixed64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedSfixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedSfixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case canoto__Scalars__FixedRepeatedFixed64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedFixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedFixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case canoto__Scalars__FixedRepeatedBool:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedBool {
				if err := canoto.ReadBool(&r, &(&c.FixedRepeatedBool)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedBool) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case canoto__Scalars__FixedRepeatedString:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedString) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadString(&r, &(&c.FixedRepeatedString)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedString)[0]) == 0
			field := (&c.FixedRepeatedString)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedString__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedString__tag):]
				if err := canoto.ReadString(&r, &field[i]); err != nil {
					return err
				}
				isZero = isZero && len(field[i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__FixedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.FixedBytes)
				expectedLengthUint64 = uint64(expectedLength)
			)
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.FixedBytes)[:], r.B)
			if canoto.IsZero(c.FixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case canoto__Scalars__RepeatedFixedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.RepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.RepeatedFixedBytes = canoto.MakeSlice(c.RepeatedFixedBytes, countMinus1+1)
			field := c.RepeatedFixedBytes
			copy((&field[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__RepeatedFixedBytes__tag):]
				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy(field[i][:], r.B)
				r.B = newB
			}
		case canoto__Scalars__FixedRepeatedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedBytes) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.FixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedBytes)[0]) == 0
			field := (&c.FixedRepeatedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
				isZero = isZero && len(field[i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__FixedRepeatedFixedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				// Ensure this field has a constant length of at least one.
				_                    = uint(len(c.FixedRepeatedFixedBytes) - 1)
				expectedLength       = len(c.FixedRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			newB := r.B[expectedLength:]
			copy((&(&c.FixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = newB

			// Read the rest of the entries, stripping the tag each time.
			field := (&c.FixedRepeatedFixedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy((&field[i])[:], r.B)
				r.B = newB
			}
			if canoto.IsZero(c.FixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__FixedRepeatedLargestFieldNumber:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedLargestFieldNumber) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedLargestFieldNumber[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedLargestFieldNumber[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__ConstRepeatedUint64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.ConstRepeatedUint64 {
				if err := canoto.ReadUint(&r, &(&c.ConstRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.ConstRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.ConstRepeatedUint64Size, uint64(len(msgBytes)))
		case canoto__Scalars__CustomType:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.CustomType).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Scalars__CustomUint32:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.CustomUint32); err != nil {
				return err
			}
			if canoto.IsZero(c.CustomUint32) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__CustomString:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.CustomString); err != nil {
				return err
			}
			if len(c.CustomString) == 0 {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__CustomBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.CustomBytes); err != nil {
				return err
			}
			if len(c.CustomBytes) == 0 {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__CustomFixedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.CustomFixedBytes)
				expectedLengthUint64 = uint64(expectedLength)
			)
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.CustomFixedBytes)[:], r.B)
			if canoto.IsZero(c.CustomFixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case canoto__Scalars__CustomRepeatedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.CustomRepeatedBytes = canoto.MakeSlice(c.CustomRepeatedBytes, countMinus1+1)
			field := c.CustomRepeatedBytes

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
			}
		case canoto__Scalars__CustomRepeatedFixedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.CustomRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.CustomRepeatedFixedBytes = canoto.MakeSlice(c.CustomRepeatedFixedBytes, countMinus1+1)
			field := c.CustomRepeatedFixedBytes
			copy((&field[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedFixedBytes__tag):]
				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy(field[i][:], r.B)
				r.B = newB
			}
		case canoto__Scalars__CustomFixedRepeatedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.CustomFixedRepeatedBytes) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.CustomFixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.CustomFixedRepeatedBytes)[0]) == 0
			field := (&c.CustomFixedRepeatedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
				isZero = isZero && len(field[i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__CustomFixedRepeatedFixedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				// Ensure this field has a constant length of at least one.
				_                    = uint(len(c.CustomFixedRepeatedFixedBytes) - 1)
				expectedLength       = len(c.CustomFixedRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			newB := r.B[expectedLength:]
			copy((&(&c.CustomFixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = newB

			// Read the rest of the entries, stripping the tag each time.
			field := (&c.CustomFixedRepeatedFixedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy((&field[i])[:], r.B)
				r.B = newB
			}
			if canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__OneOf:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Scalars__Pointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedPointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			field := c.RepeatedPointer
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = canoto.MakePointer(field[0])
				if err := (field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__Scalars__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = canoto.MakePointer(additionalField[i])
				if err := (additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__Scalars__FixedRepeatedPointer:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedPointer) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedPointer[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = canoto.MakePointer(field[i])
				if err := (field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case canoto__Scalars__Field:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case canoto__Scalars__RepeatedField:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			field := c.RepeatedField
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = field[0].MakeCanoto()
				if err := field[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__Scalars__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = additionalField[i].MakeCanoto()
				if err := additionalField[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case canoto__Scalars__FixedRepeatedField:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedField) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedField[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = field[i].MakeCanoto()
				if err := field[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Scalars) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !canoto.ValidString(c.String) {
		return false
	}
	if !(&c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	for _, v := range c.RepeatedString {
		if !canoto.ValidString(v) {
			return false
		}
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			if !(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for _, v := range &c.FixedRepeatedString {
		if !canoto.ValidString(v) {
			return false
		}
	}
	for i := range &c.FixedRepeatedLargestFieldNumber {
		if !(&(&c.FixedRepeatedLargestFieldNumber)[i]).ValidCanoto() {
			return false
		}
	}
	if !(&c.CustomType).ValidCanoto() {
		return false
	}
	if !canoto.ValidString(c.CustomString) {
		return false
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			if field[i] != nil && !(field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedField
		for i := range field {
			if !field[i].ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *Scalars) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.Int8) {
		size += uint64(len(canoto__Scalars__Int8__tag)) + canoto.SizeInt(c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		size += uint64(len(canoto__Scalars__Int16__tag)) + canoto.SizeInt(c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		size += uint64(len(canoto__Scalars__Int32__tag)) + canoto.SizeInt(c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		size += uint64(len(canoto__Scalars__Int64__tag)) + canoto.SizeInt(c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		size += uint64(len(canoto__Scalars__Uint8__tag)) + canoto.SizeUint(c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		size += uint64(len(canoto__Scalars__Uint16__tag)) + canoto.SizeUint(c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		size += uint64(len(canoto__Scalars__Uint32__tag)) + canoto.SizeUint(c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		size += uint64(len(canoto__Scalars__Uint64__tag)) + canoto.SizeUint(c.Uint64)
	}
	if !canoto.IsZero(c.Sfixed32) {
		size += uint64(len(canoto__Scalars__Sfixed32__tag)) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Fixed32) {
		size += uint64(len(canoto__Scalars__Fixed32__tag)) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Sfixed64) {
		size += uint64(len(canoto__Scalars__Sfixed64__tag)) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Fixed64) {
		size += uint64(len(canoto__Scalars__Fixed64__tag)) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Bool) {
		size += uint64(len(canoto__Scalars__Bool__tag)) + canoto.SizeBool
	}
	if len(c.String) != 0 {
		size += uint64(len(canoto__Scalars__String__tag)) + canoto.SizeBytes(c.String)
	}
	if len(c.Bytes) != 0 {
		size += uint64(len(canoto__Scalars__Bytes__tag)) + canoto.SizeBytes(c.Bytes)
	}
	(&c.LargestFieldNumber).CalculateCanotoCache()
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__LargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if len(c.RepeatedInt8) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt8 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt8Size, fieldSize)
	}
	if len(c.RepeatedInt16) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt16 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt16Size, fieldSize)
	}
	if len(c.RepeatedInt32) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt32 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt32Size, fieldSize)
	}
	if len(c.RepeatedInt64) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt64 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt64Size, fieldSize)
	}
	if len(c.RepeatedUint8) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint8 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedUint8Size, fieldSize)
	}
	if len(c.RepeatedUint16) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint16 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedUint16Size, fieldSize)
	}
	if len(c.RepeatedUint32) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint32 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedUint32Size, fieldSize)
	}
	if len(c.RepeatedUint64) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedUint64Size, fieldSize)
	}
	if num := uint64(len(c.RepeatedSfixed32)); num != 0 {
		fieldSize := num * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__RepeatedSfixed32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedFixed32)); num != 0 {
		fieldSize := num * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__RepeatedFixed32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedSfixed64)); num != 0 {
		fieldSize := num * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__RepeatedSfixed64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedFixed64)); num != 0 {
		fieldSize := num * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__RepeatedFixed64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		fieldSize := num * canoto.SizeBool
		size += uint64(len(canoto__Scalars__RepeatedBool__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	for _, v := range c.RepeatedString {
		size += uint64(len(canoto__Scalars__RepeatedString__tag)) + canoto.SizeBytes(v)
	}
	for _, v := range c.RepeatedBytes {
		size += uint64(len(canoto__Scalars__RepeatedBytes__tag)) + canoto.SizeBytes(v)
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__Scalars__RepeatedLargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt8 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedInt8Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt16 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedInt16Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt32 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedInt32Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt64 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedInt64Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint8 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedUint8Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint16 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedUint16Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint32 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedUint32Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.FixedRepeatedUint64Size, fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed32)) * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__FixedRepeatedSfixed32__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed32)) * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__FixedRepeatedFixed32__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed64)) * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__FixedRepeatedSfixed64__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed64)) * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__FixedRepeatedFixed64__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = uint64(len(c.FixedRepeatedBool)) * canoto.SizeBool
		size += uint64(len(canoto__Scalars__FixedRepeatedBool__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			size += uint64(len(canoto__Scalars__FixedRepeatedString__tag)) + canoto.SizeBytes(v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		size += uint64(len(canoto__Scalars__FixedBytes__tag)) + canoto.SizeBytes((&c.FixedBytes)[:])
	}
	if num := uint64(len(c.RepeatedFixedBytes)); num != 0 {
		fieldSize := uint64(len(canoto__Scalars__RepeatedFixedBytes__tag)) + canoto.SizeBytes((&c.RepeatedFixedBytes[0])[:])
		size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				size += uint64(len(canoto__Scalars__FixedRepeatedBytes__tag)) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			size += uint64(len(canoto__Scalars__FixedRepeatedFixedBytes__tag)) + canoto.SizeBytes((&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedLargestFieldNumber
		)
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		var fieldSize uint64
		for _, v := range &c.ConstRepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__ConstRepeatedUint64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.ConstRepeatedUint64Size, fieldSize)
	}
	(&c.CustomType).CalculateCanotoCache()
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__CustomType__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if !canoto.IsZero(c.CustomUint32) {
		size += uint64(len(canoto__Scalars__CustomUint32__tag)) + canoto.SizeFint32
	}
	if len(c.CustomString) != 0 {
		size += uint64(len(canoto__Scalars__CustomString__tag)) + canoto.SizeBytes(c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		size += uint64(len(canoto__Scalars__CustomBytes__tag)) + canoto.SizeBytes(c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		size += uint64(len(canoto__Scalars__CustomFixedBytes__tag)) + canoto.SizeBytes((&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		size += uint64(len(canoto__Scalars__CustomRepeatedBytes__tag)) + canoto.SizeBytes(v)
	}
	if num := uint64(len(c.CustomRepeatedFixedBytes)); num != 0 {
		fieldSize := uint64(len(canoto__Scalars__CustomRepeatedFixedBytes__tag)) + canoto.SizeBytes((&c.CustomRepeatedFixedBytes[0])[:])
		size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				size += uint64(len(canoto__Scalars__CustomFixedRepeatedBytes__tag)) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			size += uint64(len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag)) + canoto.SizeBytes((&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__OneOf__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__Scalars__Pointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
			}
			size += uint64(len(canoto__Scalars__RepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedPointer
		)
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += uint64(len(canoto__Scalars__FixedRepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__Field__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedField
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			size += uint64(len(canoto__Scalars__RepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedField
		)
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__Scalars__FixedRepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Scalars) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *Scalars) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *Scalars) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Int8) {
		canoto.Append(&w, canoto__Scalars__Int8__tag)
		canoto.AppendInt(&w, c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		canoto.Append(&w, canoto__Scalars__Int16__tag)
		canoto.AppendInt(&w, c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		canoto.Append(&w, canoto__Scalars__Int32__tag)
		canoto.AppendInt(&w, c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		canoto.Append(&w, canoto__Scalars__Int64__tag)
		canoto.AppendInt(&w, c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		canoto.Append(&w, canoto__Scalars__Uint8__tag)
		canoto.AppendUint(&w, c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		canoto.Append(&w, canoto__Scalars__Uint16__tag)
		canoto.AppendUint(&w, c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		canoto.Append(&w, canoto__Scalars__Uint32__tag)
		canoto.AppendUint(&w, c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		canoto.Append(&w, canoto__Scalars__Uint64__tag)
		canoto.AppendUint(&w, c.Uint64)
	}
	if !canoto.IsZero(c.Sfixed32) {
		canoto.Append(&w, canoto__Scalars__Sfixed32__tag)
		canoto.AppendFint32(&w, c.Sfixed32)
	}
	if !canoto.IsZero(c.Fixed32) {
		canoto.Append(&w, canoto__Scalars__Fixed32__tag)
		canoto.AppendFint32(&w, c.Fixed32)
	}
	if !canoto.IsZero(c.Sfixed64) {
		canoto.Append(&w, canoto__Scalars__Sfixed64__tag)
		canoto.AppendFint64(&w, c.Sfixed64)
	}
	if !canoto.IsZero(c.Fixed64) {
		canoto.Append(&w, canoto__Scalars__Fixed64__tag)
		canoto.AppendFint64(&w, c.Fixed64)
	}
	if !canoto.IsZero(c.Bool) {
		canoto.Append(&w, canoto__Scalars__Bool__tag)
		canoto.AppendBool(&w, true)
	}
	if len(c.String) != 0 {
		canoto.Append(&w, canoto__Scalars__String__tag)
		canoto.AppendBytes(&w, c.String)
	}
	if len(c.Bytes) != 0 {
		canoto.Append(&w, canoto__Scalars__Bytes__tag)
		canoto.AppendBytes(&w, c.Bytes)
	}
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__LargestFieldNumber__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.LargestFieldNumber).MarshalCanotoInto(w)
	}
	if len(c.RepeatedInt8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt8Size))
		for _, v := range c.RepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt16Size))
		for _, v := range c.RepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt32Size))
		for _, v := range c.RepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt64Size))
		for _, v := range c.RepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint8Size))
		for _, v := range c.RepeatedUint8 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint16Size))
		for _, v := range c.RepeatedUint16 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint32Size))
		for _, v := range c.RepeatedUint32 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint64Size))
		for _, v := range c.RepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedSfixed32)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed32__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint32)
		for _, v := range c.RepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedFixed32)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed32__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint32)
		for _, v := range c.RepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedSfixed64)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed64__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint64)
		for _, v := range c.RepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedFixed64)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed64__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint64)
		for _, v := range c.RepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedBool__tag)
		canoto.AppendUint(&w, num*canoto.SizeBool)
		for _, v := range c.RepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	for _, v := range c.RepeatedString {
		canoto.Append(&w, canoto__Scalars__RepeatedString__tag)
		canoto.AppendBytes(&w, v)
	}
	for _, v := range c.RepeatedBytes {
		canoto.Append(&w, canoto__Scalars__RepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedLargestFieldNumber__tag)
			canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
			w = (&field[i]).MarshalCanotoInto(w)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt8Size))
		for _, v := range &c.FixedRepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt16Size))
		for _, v := range &c.FixedRepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt32Size))
		for _, v := range &c.FixedRepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt64Size))
		for _, v := range &c.FixedRepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint8Size))
		for _, v := range &c.FixedRepeatedUint8 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint16Size))
		for _, v := range &c.FixedRepeatedUint16 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint32Size))
		for _, v := range &c.FixedRepeatedUint32 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint64Size))
		for _, v := range &c.FixedRepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed32)) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed32__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed32)) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed32__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed64)) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed64__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed64)) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed64__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = uint64(len(c.FixedRepeatedBool)) * canoto.SizeBool
		canoto.Append(&w, canoto__Scalars__FixedRepeatedBool__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedString__tag)
			canoto.AppendBytes(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		canoto.Append(&w, canoto__Scalars__FixedBytes__tag)
		canoto.AppendBytes(&w, (&c.FixedBytes)[:])
	}
	{
		field := c.RepeatedFixedBytes
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&field[i])[:])
		}
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		isZero := true
		field := &c.FixedRepeatedLargestFieldNumber
		for i := range field {
			if (&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag)
				canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
				w = (&field[i]).MarshalCanotoInto(w)
			}
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__ConstRepeatedUint64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.ConstRepeatedUint64Size))
		for _, v := range &c.ConstRepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__CustomType__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.CustomType).MarshalCanotoInto(w)
	}
	if !canoto.IsZero(c.CustomUint32) {
		canoto.Append(&w, canoto__Scalars__CustomUint32__tag)
		canoto.AppendFint32(&w, c.CustomUint32)
	}
	if len(c.CustomString) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomString__tag)
		canoto.AppendBytes(&w, c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomBytes__tag)
		canoto.AppendBytes(&w, c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		canoto.Append(&w, canoto__Scalars__CustomFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		canoto.Append(&w, canoto__Scalars__CustomRepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	{
		field := c.CustomRepeatedFixedBytes
		for i := range field {
			canoto.Append(&w, canoto__Scalars__CustomRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&field[i])[:])
		}
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__OneOf__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Scalars__Pointer__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedPointer__tag)
			var fieldSize uint64
			if field[i] != nil {
				fieldSize = (field[i]).CachedCanotoSize()
			}
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = (field[i]).MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedPointer
		for i := range field {
			if field[i] != nil && (field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedPointer__tag)
				var fieldSize uint64
				if field[i] != nil {
					fieldSize = (field[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = (field[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__Field__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.Field.MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedField
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedField__tag)
			fieldSize := field[i].CachedCanotoSize()
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = field[i].MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedField
		for i := range field {
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedField__tag)
				fieldSize := field[i].CachedCanotoSize()
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = field[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__SpecUnusedZero__Bool           = 1
	canoto__SpecUnusedZero__RepeatedBool   = 2
	canoto__SpecUnusedZero__String         = 3
	canoto__SpecUnusedZero__RepeatedString = 4
	canoto__SpecUnusedZero__Bytes          = 5
	canoto__SpecUnusedZero__RepeatedBytes  = 6

	canoto__SpecUnusedZero__Bool__tag           = "\x08" // canoto.Tag(canoto__SpecUnusedZero__Bool, canoto.Varint)
	canoto__SpecUnusedZero__RepeatedBool__tag   = "\x12" // canoto.Tag(canoto__SpecUnusedZero__RepeatedBool, canoto.Len)
	canoto__SpecUnusedZero__String__tag         = "\x1a" // canoto.Tag(canoto__SpecUnusedZero__String, canoto.Len)
	canoto__SpecUnusedZero__RepeatedString__tag = "\x22" // canoto.Tag(canoto__SpecUnusedZero__RepeatedString, canoto.Len)
	canoto__SpecUnusedZero__Bytes__tag          = "\x2a" // canoto.Tag(canoto__SpecUnusedZero__Bytes, canoto.Len)
	canoto__SpecUnusedZero__RepeatedBytes__tag  = "\x32" // canoto.Tag(canoto__SpecUnusedZero__RepeatedBytes, canoto.Len)
)

type canotoData_SpecUnusedZero struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*SpecUnusedZero) CanotoSpec(...reflect.Type) *canoto.Spec {
	s := &canoto.Spec{
		Name: "SpecUnusedZero",
		Fields: []canoto.FieldType{
			{
				FieldNumber: canoto__SpecUnusedZero__Bool,
				Name:        "Bool",
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: canoto__SpecUnusedZero__RepeatedBool,
				Name:        "RepeatedBool",
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: canoto__SpecUnusedZero__String,
				Name:        "String",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: canoto__SpecUnusedZero__RepeatedString,
				Name:        "RepeatedString",
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: canoto__SpecUnusedZero__Bytes,
				Name:        "Bytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber: canoto__SpecUnusedZero__RepeatedBytes,
				Name:        "RepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*SpecUnusedZero) MakeCanoto() *SpecUnusedZero {
	return new(SpecUnusedZero)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *SpecUnusedZero) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *SpecUnusedZero) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = SpecUnusedZero{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case canoto__SpecUnusedZero__Bool:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBool(&r, &c.Bool); err != nil {
				return err
			}
			if canoto.IsZero(c.Bool) {
				return canoto.ErrZeroValue
			}
		case canoto__SpecUnusedZero__RepeatedBool:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeBool != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedBool = canoto.MakeSlice(c.RepeatedBool, numMsgBytes/canoto.SizeBool)
			field := c.RepeatedBool
			for i := range field {
				if err := canoto.ReadBool(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case canoto__SpecUnusedZero__String:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.String); err != nil {
				return err
			}
			if len(c.String) == 0 {
				return canoto.ErrZeroValue
			}
		case canoto__SpecUnusedZero__RepeatedString:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__SpecUnusedZero__RepeatedString__tag)
			if err != nil {
				return err
			}
			c.RepeatedString = canoto.MakeSlice(c.RepeatedString, countMinus1+1)
			field := c.RepeatedString

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadString(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__SpecUnusedZero__RepeatedString__tag):]
				if err := canoto.ReadString(&r, &field[i]); err != nil {
					return err
				}
			}
		case canoto__SpecUnusedZero__Bytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Bytes); err != nil {
				return err
			}
			if len(c.Bytes) == 0 {
				return canoto.ErrZeroValue
			}
		case canoto__SpecUnusedZero__RepeatedBytes:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__SpecUnusedZero__RepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.RepeatedBytes = canoto.MakeSlice(c.RepeatedBytes, countMinus1+1)
			field := c.RepeatedBytes

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__SpecUnusedZero__RepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *SpecUnusedZero) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !canoto.ValidString(c.String) {
		return false
	}
	for _, v := range c.RepeatedString {
		if !canoto.ValidString(v) {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *SpecUnusedZero) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.Bool) {
		size += uint64(len(canoto__SpecUnusedZero__Bool__tag)) + canoto.SizeBool
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		fieldSize := num * canoto.SizeBool
		size += uint64(len(canoto__SpecUnusedZero__RepeatedBool__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if len(c.String) != 0 {
		size += uint64(len(canoto__SpecUnusedZero__String__tag)) + canoto.SizeBytes(c.String)
	}
	for _, v := range c.RepeatedString {
		size += uint64(len(canoto__SpecUnusedZero__RepeatedString__tag)) + canoto.SizeBytes(v)
	}
	if len(c.Bytes) != 0 {
		size += uint64(len(canoto__SpecUnusedZero__Bytes__tag)) + canoto.SizeBytes(c.Bytes)
	}
	for _, v := range c.RepeatedBytes {
		size += uint64(len(canoto__SpecUnusedZero__RepeatedBytes__tag)) + canoto.SizeBytes(v)
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *SpecUnusedZero) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *SpecUnusedZero) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *SpecUnusedZero) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Bool) {
		canoto.Append(&w, canoto__SpecUnusedZero__Bool__tag)
		canoto.AppendBool(&w, true)
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		canoto.Append(&w, canoto__SpecUnusedZero__RepeatedBool__tag)
		canoto.AppendUint(&w, num*canoto.SizeBool)
		for _, v := range c.RepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	if len(c.String) != 0 {
		canoto.Append(&w, canoto__SpecUnusedZero__String__tag)
		canoto.AppendBytes(&w, c.String)
	}
	for _, v := range c.RepeatedString {
		canoto.Append(&w, canoto__SpecUnusedZero__RepeatedString__tag)
		canoto.AppendBytes(&w, v)
	}
	if len(c.Bytes) != 0 {
		canoto.Append(&w, canoto__SpecUnusedZero__Bytes__tag)
		canoto.AppendBytes(&w, c.Bytes)
	}
	for _, v := range c.RepeatedBytes {
		canoto.Append(&w, canoto__SpecUnusedZero__RepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	return w
}
