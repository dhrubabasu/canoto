package generate

import (
	"encoding/hex"
	"errors"
	"fmt"
	"go/parser"
	"go/token"
	"io"
	"os"
	"slices"
	"strings"

	"github.com/StephenButtolph/canoto"
)

const (
	goExtension     = ".go"
	canotoExtension = ".canoto.go"

	goTestExtension     = "_test.go"
	canotoTestExtension = ".canoto_test.go"

	defaultCanotoImporter = "canoto."
)

var errNonGoExtension = errors.New("file must be a go file")

// Canoto generates the canoto serialization logic for the provided file.
func Canoto(
	inputFilePath string,
	canotoImport string,
	internal bool,
) error {
	var outputFilePath string
	switch {
	case strings.HasSuffix(inputFilePath, goTestExtension):
		outputFilePath = inputFilePath[:len(inputFilePath)-len(goTestExtension)] + canotoTestExtension
	case strings.HasSuffix(inputFilePath, goExtension):
		outputFilePath = inputFilePath[:len(inputFilePath)-len(goExtension)] + canotoExtension
	default:
		return errNonGoExtension
	}

	// Create a new parser
	fs := token.NewFileSet()
	f, err := parser.ParseFile(fs, inputFilePath, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	packageName, messages, err := parse(fs, f, canotoImport, internal)
	if err != nil {
		return err
	}
	if len(messages) == 0 {
		return nil
	}

	outputFile, err := os.Create(outputFilePath)
	if err != nil {
		return err
	}
	defer outputFile.Close()

	return writeCanoto(outputFile, inputFilePath, packageName, messages, canotoImport, internal)
}

func writeCanoto(
	w io.Writer,
	source string,
	packageName string,
	messages []message,
	canotoImport string,
	internal bool,
) error {
	const fileTemplate = `// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto ${version}
// source: ${source}

package ${package}

import (
	"io"
	"reflect"
	"sync/atomic"
${canotoImport})

// Ensure that unused imports do not error
var (
	_ atomic.Uint64

	_ = io.ErrUnexpectedEOF
)
`
	// Only include the import for canoto if this is not an internal file.
	if internal {
		canotoImport = ""
	} else {
		canotoImport = fmt.Sprintf("\n\t%s\n", canotoImport)
	}
	err := writeTemplate(w, fileTemplate, map[string]string{
		"version":      canoto.Version,
		"source":       source,
		"package":      packageName,
		"canotoImport": canotoImport,
	})
	if err != nil {
		return err
	}

	var selector string
	if !internal {
		selector = defaultCanotoImporter
	}
	for _, m := range messages {
		if err := writeStruct(w, m, selector); err != nil {
			return err
		}
	}
	return nil
}

func writeStruct(w io.Writer, m message, canotoSelector string) error {
	const structTemplate = `
const (
${numberConstants}
${tagConstants})

type canotoData_${structName} struct {
${sizeCache}${oneOfCache}}

// CanotoSpec returns the specification of this canoto message.
func (*${structName}${generics}) CanotoSpec(${typesDecl}...reflect.Type) *${selector}Spec {
${appendTypes}${zero}	s := &${selector}Spec{
		Name: "${structName}",
		Fields: []${selector}FieldType{
${spec}		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*${structName}${generics}) MakeCanoto() *${structName}${generics} {
	return new(${structName}${generics})
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *${structName}${generics}) UnmarshalCanoto(bytes []byte) error {
	r := ${selector}Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [${selector}Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *${structName}${generics}) UnmarshalCanotoFrom(r ${selector}Reader) error {
	// Zero the struct before unmarshaling.
	*c = ${structName}${generics}{}
	${storePrefix}c.canotoData.size${storeJoin}uint64(len(r.B))${storeSuffix}

	var minField uint32
	for ${selector}HasNext(&r) {
		field, wireType, err := ${selector}ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return ${selector}ErrInvalidFieldOrder
		}

		switch field {
${unmarshal}		default:
			return ${selector}ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *${structName}${generics}) ValidCanoto() bool {
	if c == nil {
		return true
	}
${validOneOf}${valid}	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.${concurrencyWarning}
func (c *${structName}${generics}) CalculateCanotoCache() {
	if c == nil {
		return
	}
${sizeVars}${size}${assignSizeVars}}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *${structName}${generics}) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return ${loadPrefix}c.canotoData.size${loadSuffix}
}${oneOfCacheAccessors}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.${concurrencyWarning}
func (c *${structName}${generics}) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := ${selector}Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [${selector}Writer] and returns the
// resulting [${selector}Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.${concurrencyWarning}
func (c *${structName}${generics}) MarshalCanotoInto(w ${selector}Writer) ${selector}Writer {
	if c == nil {
		return w
	}
${marshal}	return w
}
`

	var (
		loadPrefix         = "atomic.LoadUint64(&"
		loadSuffix         = ")"
		storePrefix        = "atomic.StoreUint64(&"
		storeJoin          = ", "
		storeSuffix        = ")"
		concurrencyWarning = `
//
// It is not safe to copy this struct concurrently.`
	)
	if m.noCopy {
		loadPrefix = ""
		loadSuffix = ".Load()"
		storePrefix = ""
		storeJoin = ".Store("
		storeSuffix = ")"
		concurrencyWarning = ""
	}

	generics := makeGenerics(m)

	var (
		typesDecl   string
		appendTypes string
	)
	hasSubMessages := false
	for _, f := range m.fields {
		if f.canotoType.IsMessage() {
			hasSubMessages = true
		}
	}
	if hasSubMessages {
		typesDecl = "types "
		appendTypes = fmt.Sprintf("\ttypes = append(types, reflect.TypeOf(%s%s{}))\n", m.name, generics)
	}

	return writeTemplate(w, structTemplate, map[string]string{
		"typesDecl":           typesDecl,
		"appendTypes":         appendTypes,
		"numberConstants":     makeNumberConstants(m),
		"tagConstants":        makeTagConstants(m),
		"structName":          m.name,
		"generics":            generics,
		"selector":            canotoSelector,
		"sizeCache":           makeSizeCache(m),
		"oneOfCache":          makeOneOfCache(m),
		"spec":                makeSpec(m),
		"unmarshal":           makeUnmarshal(m),
		"validOneOf":          makeValidOneOf(m),
		"valid":               makeValid(m),
		"concurrencyWarning":  concurrencyWarning,
		"sizeVars":            makeSizeVars(m),
		"size":                makeSize(m),
		"assignSizeVars":      makeAssignSizeVars(m),
		"loadPrefix":          loadPrefix,
		"loadSuffix":          loadSuffix,
		"storePrefix":         storePrefix,
		"storeJoin":           storeJoin,
		"storeSuffix":         storeSuffix,
		"oneOfCacheAccessors": makeOneOfCacheAccessors(m),
		"marshal":             makeMarshal(m),
		"zero":                makeZeroVarName(m, generics),
	})
}

func makeZeroVarName(m message, generics string) string {
	zeroIsUnusedTypes := []canotoType{
		canotoBool,
		canotoRepeatedBool,
		canotoString,
		canotoRepeatedString,
		canotoBytes,
		canotoRepeatedBytes,
	}

	for _, f := range m.fields {
		if !slices.Contains(zeroIsUnusedTypes, f.canotoType) {
			return makeTemplate(`	var zero ${structName}${generics}
`, map[string]string{
				"structName": m.name,
				"generics":   generics,
			})
		}
	}

	return ""
}

func makeGenerics(m message) string {
	if m.numTypes == 0 {
		return ""
	}

	var s strings.Builder
	_, _ = s.WriteString("[")
	for i := range m.numTypes {
		if i != 0 {
			_, _ = s.WriteString(", ")
		}
		_, _ = s.WriteString(fmt.Sprintf("T%d", i+1))
	}
	_, _ = s.WriteString("]")
	return s.String()
}

func makeNumberConstants(m message) string {
	const fieldSizeOverhead = len("canoto____")
	var largestNumberConstSize int
	for _, f := range m.fields {
		numberConstSize := fieldSizeOverhead + len(m.canonicalizedName) + len(f.canonicalizedName)
		largestNumberConstSize = max(largestNumberConstSize, numberConstSize)
	}

	var (
		template = fmt.Sprintf("\t%%-%ds = %%d\n",
			largestNumberConstSize,
		)
		s strings.Builder
	)
	for _, f := range m.fields {
		field := fmt.Sprintf("canoto__%s__%s", m.canonicalizedName, f.canonicalizedName)
		_, _ = fmt.Fprintf(&s, template, field, f.fieldNumber)
	}
	return s.String()
}

func makeTagConstants(m message) string {
	const tagSizeOverhead = len("canoto______tag")
	var (
		largestTagConstSize int
		largestTagSize      int
	)
	for _, f := range m.fields {
		tagConstSize := tagSizeOverhead + len(m.canonicalizedName) + len(f.canonicalizedName)
		largestTagConstSize = max(largestTagConstSize, tagConstSize)

		wireType := f.canotoType.WireType()
		tagBytes := canoto.Tag(f.fieldNumber, wireType)
		tagSize := 2 + 4*len(tagBytes)
		largestTagSize = max(largestTagSize, tagSize)
	}

	var (
		template = fmt.Sprintf("\t%%-%ds = %%-%ds // canoto.Tag(%%s, canoto.%%s)\n",
			largestTagConstSize,
			largestTagSize,
		)
		s strings.Builder
	)
	for _, f := range m.fields {
		field := fmt.Sprintf("canoto__%s__%s", m.canonicalizedName, f.canonicalizedName)
		tag := field + "__tag"

		var tagString strings.Builder
		_, _ = tagString.WriteString(`"`)
		wireType := f.canotoType.WireType()
		tagBytes := canoto.Tag(f.fieldNumber, wireType)
		tagHex := hex.EncodeToString(tagBytes)
		for i := 0; i < len(tagHex); i += 2 {
			_, _ = fmt.Fprintf(&tagString, "\\x%s", tagHex[i:i+2])
		}
		_, _ = tagString.WriteString(`"`)

		_, _ = fmt.Fprintf(&s, template, tag, &tagString, field, wireType)
	}
	return s.String()
}

func makeSizeCache(m message) string {
	const (
		sizeVar    = "size"
		sizeSuffix = "Size"
	)
	largestNameSize := len(sizeVar)
	for _, f := range m.fields {
		if !f.canotoType.IsRepeated() || !f.canotoType.IsVarint() {
			continue
		}

		largestNameSize = max(largestNameSize, len(f.name)+len(sizeSuffix))
	}

	sizeType := "uint64"
	if m.noCopy {
		sizeType = "atomic.Uint64"
	}

	var (
		s        strings.Builder
		template = fmt.Sprintf("\t%%-%ds %s\n", largestNameSize, sizeType)
	)
	_, _ = fmt.Fprintf(&s, template, sizeVar)
	for _, f := range m.fields {
		if !f.canotoType.IsRepeated() || !f.canotoType.IsVarint() {
			continue
		}

		_, _ = fmt.Fprintf(&s, template, f.name+sizeSuffix)
	}
	return s.String()
}

func makeOneOfCache(m message) string {
	oneOfs := m.OneOfs()
	if len(oneOfs) == 0 {
		return ""
	}

	var largestNameSize int
	for _, oneOf := range oneOfs {
		largestNameSize = max(largestNameSize, len(oneOf))
	}

	oneOfType := "uint32"
	if m.noCopy {
		oneOfType = "atomic.Uint32"
	}

	const oneOfSuffix = "OneOf"
	var (
		template = fmt.Sprintf("\t%%-%ds %s\n", largestNameSize+len(oneOfSuffix), oneOfType)
		s        strings.Builder
	)
	_, _ = s.WriteString("\n")
	for _, oneOf := range oneOfs {
		_, _ = fmt.Fprintf(&s, template, oneOf+oneOfSuffix)
	}
	return s.String()
}

func makeSpec(m message) string {
	return writeMessage(m, messageTemplate{
		ints: typeTemplate{
			single: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				OneOf:       "${oneOf}",
				Type${suffix}:${signedSpace}    ${selector}SizeOf(zero.${fieldName}),
			},
`,
			repeated: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				Repeated:    true,
				OneOf:       "${oneOf}",
				Type${suffix}:${signedSpace}    ${selector}SizeOf(${selector}MakeEntry(zero.${fieldName})),
			},
`,
			fixedRepeated: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				FixedLength: uint64(len(zero.${fieldName})),
				Repeated:    true,
				OneOf:       "${oneOf}",
				Type${suffix}:${signedSpace}    ${selector}SizeOf(${selector}MakeEntry(zero.${fieldName}[:])),
			},
`,
		},
		fints: typeTemplate{
			single: `			${selector}FieldTypeFromFint(
				/*type inference:*/ zero.${fieldName},
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "${oneOf}",
			),
`,
			repeated: `			${selector}FieldTypeFromFint(
				/*type inference:*/ ${selector}MakeEntry(zero.${fieldName}),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
			),
`,
			fixedRepeated: `			${selector}FieldTypeFromFint(
				/*type inference:*/ ${selector}MakeEntry(zero.${fieldName}[:]),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ uint64(len(zero.${fieldName})),
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
			),
`,
		},
		bools: typeTemplate{
			single: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				OneOf:       "${oneOf}",
				TypeBool:    true,
			},
`,
			repeated: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				Repeated:    true,
				OneOf:       "${oneOf}",
				TypeBool:    true,
			},
`,
			fixedRepeated: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				FixedLength: uint64(len(zero.${fieldName})),
				Repeated:    true,
				OneOf:       "${oneOf}",
				TypeBool:    true,
			},
`,
		},
		strings: typeTemplate{
			single: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				OneOf:       "${oneOf}",
				TypeString:  true,
			},
`,
			repeated: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				Repeated:    true,
				OneOf:       "${oneOf}",
				TypeString:  true,
			},
`,
			fixedRepeated: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				FixedLength: uint64(len(zero.${fieldName})),
				Repeated:    true,
				OneOf:       "${oneOf}",
				TypeString:  true,
			},
`,
		},
		bytesTemplate: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				OneOf:       "${oneOf}",
				TypeBytes:   true,
			},
`,
		repeatedBytesTemplate: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				Repeated:    true,
				OneOf:       "${oneOf}",
				TypeBytes:   true,
			},
`,
		fixedBytesTemplate: `			{
				FieldNumber:    ${fieldNumberConst},
				Name:           "${fieldName}",
				OneOf:          "${oneOf}",
				TypeFixedBytes: uint64(len(zero.${fieldName})),
			},
`,
		repeatedFixedBytesTemplate: `			{
				FieldNumber:    ${fieldNumberConst},
				Name:           "${fieldName}",
				Repeated:       true,
				OneOf:          "${oneOf}",
				TypeFixedBytes: uint64(len(zero.${fieldName}[0])),
			},
`,
		fixedRepeatedBytesTemplate: `			{
				FieldNumber: ${fieldNumberConst},
				Name:        "${fieldName}",
				FixedLength: uint64(len(zero.${fieldName})),
				Repeated:    true,
				OneOf:       "${oneOf}",
				TypeBytes:   true,
			},
`,
		fixedRepeatedFixedBytesTemplate: `			{
				FieldNumber:    ${fieldNumberConst},
				Name:           "${fieldName}",
				FixedLength:    uint64(len(zero.${fieldName})),
				Repeated:       true,
				OneOf:          "${oneOf}",
				TypeFixedBytes: uint64(len(zero.${fieldName}[0])),
			},
`,
		values: typeTemplate{
			single: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${genericTypeCast}(&zero.${fieldName}),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
			repeated: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${genericTypeCast}(${selector}MakeEntryNilPointer(zero.${fieldName})),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
			fixedRepeated: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${genericTypeCast}(${selector}MakeEntryNilPointer(zero.${fieldName}[:])),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ uint64(len(zero.${fieldName})),
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
		},
		pointers: typeTemplate{
			single: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${genericTypeCast}(zero.${fieldName}),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
			repeated: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${genericTypeCast}(${selector}MakeEntry(zero.${fieldName})),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
			fixedRepeated: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${genericTypeCast}(${selector}MakeEntry(zero.${fieldName}[:])),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ uint64(len(zero.${fieldName})),
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
		},
		fields: typeTemplate{
			single: `			${selector}FieldTypeFromField(
				/*type inference:*/ zero.${fieldName},
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
			repeated: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${selector}MakeEntry(zero.${fieldName}),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,

			fixedRepeated: `			${selector}FieldTypeFromField(
				/*type inference:*/ ${selector}MakeEntry(zero.${fieldName}[:]),
				/*FieldNumber:   */ ${fieldNumberConst},
				/*Name:          */ "${fieldName}",
				/*FixedLength:   */ uint64(len(zero.${fieldName})),
				/*Repeated:      */ true,
				/*OneOf:         */ "${oneOf}",
				/*types:         */ types,
			),
`,
		},
	})
}

func makeUnmarshal(m message) string {
	const (
		intTemplate = `		case ${fieldNumberConst}:
			if wireType != ${selector}${wireType} {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			if err := ${selector}Read${suffix}(&r, &c.${fieldName}); err != nil {
				return err
			}
			if ${selector}IsZero(c.${fieldName}) {
				return ${selector}ErrZeroValue
			}
`
		repeatedFixedSizeTemplate = `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return ${selector}ErrZeroValue
			}
			if numMsgBytes%${selector}Size${suffix} != 0 {
				return ${selector}ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.${fieldName} = ${selector}MakeSlice(c.${fieldName}, numMsgBytes/${selector}Size${suffix})
			field := c.${fieldName}
			for i := range field {
				if err := ${selector}Read${suffix}(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
`
		fixedRepeatedFixedSizeTemplate = `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.${fieldName} {
				if err := ${selector}Read${suffix}(&r, &(&c.${fieldName})[i]); err != nil {
					return err
				}
			}
			if ${selector}HasNext(&r) {
				return ${selector}ErrInvalidLength
			}
			if ${selector}IsZero(c.${fieldName}) {
				return ${selector}ErrZeroValue
			}
			r.B = remainingBytes
`
		bytesTemplate = `		case ${fieldNumberConst}:
			if wireType != ${selector}${wireType} {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			if err := ${selector}Read${suffix}(&r, &c.${fieldName}); err != nil {
				return err
			}
			if len(c.${fieldName}) == 0 {
				return ${selector}ErrZeroValue
			}
`
		repeatedBytesTemplate = `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := ${selector}ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := ${selector}CountBytes(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag)
			if err != nil {
				return err
			}
			c.${fieldName} = ${selector}MakeSlice(c.${fieldName}, countMinus1+1)
			field := c.${fieldName}

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := ${selector}Read${suffix}(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				if err := ${selector}Read${suffix}(&r, &field[i]); err != nil {
					return err
				}
			}
`
		fixedRepeatedBytes = `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.${fieldName}) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			if err := ${selector}Read${suffix}(&r, &(&c.${fieldName})[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.${fieldName})[0]) == 0
			field := (&c.${fieldName})[1:]
			for i := range field {
				if !${selector}HasPrefix(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag) {
					return ${selector}ErrUnknownField
				}
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				if err := ${selector}Read${suffix}(&r, &field[i]); err != nil {
					return err
				}
				isZero = isZero && len(field[i]) == 0
			}
			if isZero {
				return ${selector}ErrZeroValue
			}
`
	)
	return writeMessage(m, messageTemplate{
		ints: typeTemplate{
			single: intTemplate,
			repeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ${selector}ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.${fieldName} = ${selector}MakeSlice(c.${fieldName}, ${selector}CountInts(msgBytes))
			field := c.${fieldName}
			for i := range field {
				if err := ${selector}Read${suffix}(&r, &field[i]); err != nil {
					return err
				}
			}
			if ${selector}HasNext(&r) {
				return ${selector}ErrInvalidLength
			}
			r.B = remainingBytes
			${storePrefix}c.canotoData.${fieldName}Size${storeJoin}uint64(len(msgBytes))${storeSuffix}
`,
			fixedRepeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.${fieldName} {
				if err := ${selector}Read${suffix}(&r, &(&c.${fieldName})[i]); err != nil {
					return err
				}
			}
			if ${selector}HasNext(&r) {
				return ${selector}ErrInvalidLength
			}
			if ${selector}IsZero(c.${fieldName}) {
				return ${selector}ErrZeroValue
			}
			r.B = remainingBytes
			${storePrefix}c.canotoData.${fieldName}Size${storeJoin}uint64(len(msgBytes))${storeSuffix}
`,
		},
		fints: typeTemplate{
			single:        intTemplate,
			repeated:      repeatedFixedSizeTemplate,
			fixedRepeated: fixedRepeatedFixedSizeTemplate,
		},
		bools: typeTemplate{
			single:        intTemplate,
			repeated:      repeatedFixedSizeTemplate,
			fixedRepeated: fixedRepeatedFixedSizeTemplate,
		},
		strings: typeTemplate{
			single:        bytesTemplate,
			repeated:      repeatedBytesTemplate,
			fixedRepeated: fixedRepeatedBytes,
		},
		bytesTemplate:         bytesTemplate,
		repeatedBytesTemplate: repeatedBytesTemplate,
		fixedBytesTemplate: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			const (
				expectedLength       = len(c.${fieldName})
				expectedLengthUint64 = uint64(expectedLength)
			)
			var length uint64
			if err := ${selector}ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return ${selector}ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.${fieldName})[:], r.B)
			if ${selector}IsZero(c.${fieldName}) {
				return ${selector}ErrZeroValue
			}
			r.B = r.B[expectedLength:]
`,
		repeatedFixedBytesTemplate: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			const (
				expectedLength       = len(c.${fieldName}[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := ${selector}ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return ${selector}ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := ${selector}CountBytes(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag)
			if err != nil {
				return err
			}

			c.${fieldName} = ${selector}MakeSlice(c.${fieldName}, countMinus1+1)
			field := c.${fieldName}
			copy((&field[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				if err := ${selector}ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return ${selector}ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy(field[i][:], r.B)
				r.B = newB
			}
`,
		fixedRepeatedBytesTemplate: fixedRepeatedBytes,
		fixedRepeatedFixedBytesTemplate: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			const (
				// Ensure this field has a constant length of at least one.
				_                    = uint(len(c.${fieldName}) - 1)
				expectedLength       = len(c.${fieldName}[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := ${selector}ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return ${selector}ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			newB := r.B[expectedLength:]
			copy((&(&c.${fieldName})[0])[:], r.B)
			r.B = newB

			// Read the rest of the entries, stripping the tag each time.
			field := (&c.${fieldName})[1:]
			for i := range field {
				if !${selector}HasPrefix(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag) {
					return ${selector}ErrUnknownField
				}
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]

				if err := ${selector}ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return ${selector}ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy((&field[i])[:], r.B)
				r.B = newB
			}
			if ${selector}IsZero(c.${fieldName}) {
				return ${selector}ErrZeroValue
			}
`,
		values: typeTemplate{
			single: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ${selector}ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := ${genericTypeCast}(&c.${fieldName}).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
`,
			repeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := ${selector}CountBytes(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag)
			if err != nil {
				return err
			}

			c.${fieldName} = ${selector}MakeSlice(c.${fieldName}, countMinus1+1)
			field := c.${fieldName}
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := ${genericTypeCast}(&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				r.Unsafe = true
				if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := ${genericTypeCast}(&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
`,
			fixedRepeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.${fieldName}) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := ${genericTypeCast}(&c.${fieldName}[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.${fieldName}[1:]
			for i := range field {
				if !${selector}HasPrefix(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag) {
					return ${selector}ErrUnknownField
				}
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				r.Unsafe = true
				if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := ${genericTypeCast}(&field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return ${selector}ErrZeroValue
			}
`,
		},
		pointers: typeTemplate{
			single: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ${selector}ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.${fieldName} = ${selector}MakePointer(c.${fieldName})
			if err := ${genericTypeCast}(c.${fieldName}).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
`,
			repeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := ${selector}CountBytes(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag)
			if err != nil {
				return err
			}

			c.${fieldName} = ${selector}MakeSlice(c.${fieldName}, countMinus1+1)
			field := c.${fieldName}
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = ${selector}MakePointer(field[0])
				if err := ${genericTypeCast}(field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				r.Unsafe = true
				if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = ${selector}MakePointer(additionalField[i])
				if err := ${genericTypeCast}(additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
`,
			fixedRepeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.${fieldName}) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.${fieldName}[0] = ${selector}MakePointer(c.${fieldName}[0])
				if err := ${genericTypeCast}(c.${fieldName}[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.${fieldName}[1:]
			for i := range field {
				if !${selector}HasPrefix(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag) {
					return ${selector}ErrUnknownField
				}
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				r.Unsafe = true
				if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = ${selector}MakePointer(field[i])
				if err := ${genericTypeCast}(field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return ${selector}ErrZeroValue
			}
`,
		},
		fields: typeTemplate{
			single: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ${selector}ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.${fieldName} = c.${fieldName}.MakeCanoto()
			if err := c.${fieldName}.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
`,
			repeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := ${selector}CountBytes(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag)
			if err != nil {
				return err
			}

			c.${fieldName} = ${selector}MakeSlice(c.${fieldName}, countMinus1+1)
			field := c.${fieldName}
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = field[0].MakeCanoto()
				if err := field[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				r.Unsafe = true
				if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = additionalField[i].MakeCanoto()
				if err := additionalField[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
`,
			fixedRepeated: `		case ${fieldNumberConst}:
			if wireType != ${selector}Len {
				return ${selector}ErrUnexpectedWireType
			}${unmarshalOneOf}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.${fieldName}) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.${fieldName}[0] = c.${fieldName}[0].MakeCanoto()
				if err := c.${fieldName}[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.${fieldName}[1:]
			for i := range field {
				if !${selector}HasPrefix(r.B, canoto__${escapedStructName}__${escapedFieldName}__tag) {
					return ${selector}ErrUnknownField
				}
				r.B = r.B[len(canoto__${escapedStructName}__${escapedFieldName}__tag):]
				r.Unsafe = true
				if err := ${selector}ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = field[i].MakeCanoto()
				if err := field[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return ${selector}ErrZeroValue
			}
`,
		},
	})
}

func makeValidOneOf(m message) string {
	const oneOfSuffix = "OneOf"
	var (
		template = "\tvar %s uint32\n"
		s        strings.Builder
	)
	for _, oneOf := range m.OneOfs() {
		_, _ = fmt.Fprintf(&s, template, oneOf+oneOfSuffix)
	}

	const (
		functionTemplate = `	if !${selector}IsZero(c.${fieldName}) {
		if ${oneOf}OneOf != 0 {
			return false
		}
		${oneOf}OneOf = ${fieldNumberConst}
	}
`
		repeatedTemplate = `	if len(c.${fieldName}) != 0 {
		if ${oneOf}OneOf != 0 {
			return false
		}
		${oneOf}OneOf = ${fieldNumberConst}
	}
`
	)
	var (
		primitiveTemplate = typeTemplate{
			single:        functionTemplate,
			repeated:      repeatedTemplate,
			fixedRepeated: functionTemplate,
		}
		t = messageTemplate{
			ints:    primitiveTemplate,
			fints:   primitiveTemplate,
			bools:   primitiveTemplate,
			strings: primitiveTemplate,

			bytesTemplate:              repeatedTemplate,
			repeatedBytesTemplate:      repeatedTemplate,
			fixedBytesTemplate:         functionTemplate,
			repeatedFixedBytesTemplate: repeatedTemplate,
			fixedRepeatedBytesTemplate: `	{
		isZero := true
		for _, v := range c.${fieldName} {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			if ${oneOf}OneOf != 0 {
				return false
			}
			${oneOf}OneOf = ${fieldNumberConst}
		}
	}
`,
			fixedRepeatedFixedBytesTemplate: functionTemplate,

			values: typeTemplate{
				single: `	if ${genericTypeCast}(&c.${fieldName}).CalculateCanotoCache(); ${genericTypeCast}(&c.${fieldName}).CachedCanotoSize() != 0 {
		if ${oneOf}OneOf != 0 {
			return false
		}
		${oneOf}OneOf = ${fieldNumberConst}
	}
`,
				repeated: repeatedTemplate,
				fixedRepeated: `	{
		isZero := true
		field := c.${fieldName}
		for i := range field {
			if ${genericTypeCast}(&field[i]).CalculateCanotoCache(); ${genericTypeCast}(&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			if ${oneOf}OneOf != 0 {
				return false
			}
			${oneOf}OneOf = ${fieldNumberConst}
		}
	}
`,
			},
			pointers: typeTemplate{
				single: `	if c.${fieldName} != nil {
		${genericTypeCast}(c.${fieldName}).CalculateCanotoCache()
		if ${genericTypeCast}(c.${fieldName}).CachedCanotoSize() != 0 {
			if ${oneOf}OneOf != 0 {
				return false
			}
			${oneOf}OneOf = ${fieldNumberConst}
		}
	}
`,
				repeated: repeatedTemplate,
				fixedRepeated: `	{
		isZero := true
		field := c.${fieldName}
		for i := range field {
			if field[i] == nil {
				continue
			}
			field[i].CalculateCanotoCache()
			if ${genericTypeCast}(field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			if ${oneOf}OneOf != 0 {
				return false
			}
			${oneOf}OneOf = ${fieldNumberConst}
		}
	}
`,
			},
			fields: typeTemplate{
				single: `	c.${fieldName}.CalculateCanotoCache()
	if c.${fieldName}.CachedCanotoSize() != 0 {
		if ${oneOf}OneOf != 0 {
			return false
		}
		${oneOf}OneOf = ${fieldNumberConst}
	}
`,
				repeated: repeatedTemplate,
				fixedRepeated: `	{
		isZero := true
		field := c.${fieldName}
		for i := range c.${fieldName} {
			field[i].CalculateCanotoCache()
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			if ${oneOf}OneOf != 0 {
				return false
			}
			${oneOf}OneOf = ${fieldNumberConst}
		}
	}
`,
			},
		}
	)

	for _, f := range m.fields {
		if f.oneOfName == "" {
			continue
		}

		_ = writeField(&s, f, t)
	}
	return s.String()
}

func makeValid(m message) string {
	return writeMessage(m, messageTemplate{
		strings: typeTemplate{
			single: `	if !${selector}ValidString(c.${fieldName}) {
		return false
	}
`,
			repeated: `	for _, v := range c.${fieldName} {
		if !${selector}ValidString(v) {
			return false
		}
	}
`,
			fixedRepeated: `	for _, v := range &c.${fieldName} {
		if !${selector}ValidString(v) {
			return false
		}
	}
`,
		},
		values: typeTemplate{
			single: `	if !${genericTypeCast}(&c.${fieldName}).ValidCanoto() {
		return false
	}
`,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			if !${genericTypeCast}(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
`,
			fixedRepeated: `	for i := range &c.${fieldName} {
		if !${genericTypeCast}(&(&c.${fieldName})[i]).ValidCanoto() {
			return false
		}
	}
`,
		},
		pointers: typeTemplate{
			single: `	if c.${fieldName} != nil && !${genericTypeCast}(c.${fieldName}).ValidCanoto() {
		return false
	}
`,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			if field[i] != nil && !${genericTypeCast}(field[i]).ValidCanoto() {
				return false
			}
		}
	}
`,
			fixedRepeated: `	for i := range &c.${fieldName} {
		if (&c.${fieldName})[i] != nil && !${genericTypeCast}((&c.${fieldName})[i]).ValidCanoto() {
			return false
		}
	}
`,
		},
		fields: typeTemplate{
			single: `	if !c.${fieldName}.ValidCanoto() {
		return false
	}
`,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			if !field[i].ValidCanoto() {
				return false
			}
		}
	}
`,
			fixedRepeated: `	for i := range &c.${fieldName} {
		if !(&c.${fieldName})[i].ValidCanoto() {
			return false
		}
	}
`,
		},
	})
}

func makeSizeVars(m message) string {
	var s strings.Builder
	_, _ = fmt.Fprint(&s, "\tvar size uint64\n")

	const (
		oneOfSuffix   = "OneOf"
		oneOfTemplate = "\tvar %s uint32\n"
	)
	for _, oneOf := range m.OneOfs() {
		_, _ = fmt.Fprintf(&s, oneOfTemplate, oneOf+oneOfSuffix)
	}
	return s.String()
}

func makeSize(m message) string {
	const (
		fixedSizeTemplate = `	if !${selector}IsZero(c.${fieldName}) {
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}Size${suffix}${sizeOneOf}
	}
`
		repeatedFixedSizeTemplate = `	if num := uint64(len(c.${fieldName})); num != 0 {
		fieldSize := num * ${selector}Size${suffix}
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize${sizeOneOf}
	}
`
		fixedRepeatedFixedSizeTemplate = `	if !${selector}IsZero(c.${fieldName}) {
		const fieldSize = uint64(len(c.${fieldName})) * ${selector}Size${suffix}
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + fieldSize + ${selector}SizeUint(fieldSize)${sizeOneOf}
	}
`
		bytesTemplate = `	if len(c.${fieldName}) != 0 {
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeBytes(c.${fieldName})${sizeOneOf}
	}
`
		repeatedBytesTemplate = `	for _, v := range c.${fieldName} {
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeBytes(v)${sizeOneOf}
	}
`
	)
	return writeMessage(m, messageTemplate{
		ints: typeTemplate{
			single: `	if !${selector}IsZero(c.${fieldName}) {
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}Size${suffix}(c.${fieldName})${sizeOneOf}
	}
`,
			repeated: `	if len(c.${fieldName}) != 0 {
		var fieldSize uint64
		for _, v := range c.${fieldName} {
			fieldSize += ${selector}Size${suffix}(v)
		}
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize
		${storePrefix}c.canotoData.${fieldName}Size${storeJoin}fieldSize${storeSuffix}${sizeOneOf}
	}
`,
			fixedRepeated: `	if !${selector}IsZero(c.${fieldName}) {
		var fieldSize uint64
		for _, v := range &c.${fieldName} {
			fieldSize += ${selector}Size${suffix}(v)
		}
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize
		${storePrefix}c.canotoData.${fieldName}Size${storeJoin}fieldSize${storeSuffix}${sizeOneOf}
	}
`,
		},
		fints: typeTemplate{
			single:        fixedSizeTemplate,
			repeated:      repeatedFixedSizeTemplate,
			fixedRepeated: fixedRepeatedFixedSizeTemplate,
		},
		bools: typeTemplate{
			single:        fixedSizeTemplate,
			repeated:      repeatedFixedSizeTemplate,
			fixedRepeated: fixedRepeatedFixedSizeTemplate,
		},
		strings: typeTemplate{
			single:   bytesTemplate,
			repeated: repeatedBytesTemplate,
			fixedRepeated: `	if !${selector}IsZero(c.${fieldName}) {
		for _, v := range &c.${fieldName} {
			size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeBytes(v)
		}${sizeOneOf}
	}
`,
		},
		bytesTemplate:         bytesTemplate,
		repeatedBytesTemplate: repeatedBytesTemplate,
		fixedBytesTemplate: `	if !${selector}IsZero(c.${fieldName}) {
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeBytes((&c.${fieldName})[:])${sizeOneOf}
	}
`,
		repeatedFixedBytesTemplate: `	if num := uint64(len(c.${fieldName})); num != 0 {
		fieldSize := uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeBytes((&c.${fieldName}[0])[:])
		size += num * fieldSize${sizeOneOf}
	}
`,
		fixedRepeatedBytesTemplate: `	{
		isZero := true
		for _, v := range c.${fieldName} {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.${fieldName} {
				size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeBytes(v)
			}${sizeOneOfIndent}
		}
	}
`,
		fixedRepeatedFixedBytesTemplate: `	if !${selector}IsZero(c.${fieldName}) {
		for i := range c.${fieldName} {
			size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeBytes((&(&c.${fieldName})[i])[:])
		}${sizeOneOf}
	}
`,
		values: typeTemplate{
			single: `	${genericTypeCast}(&c.${fieldName}).CalculateCanotoCache()
	if fieldSize := ${genericTypeCast}(&c.${fieldName}).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize${sizeOneOf}
	}
`,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			${genericTypeCast}(&field[i]).CalculateCanotoCache()
			fieldSize := ${genericTypeCast}(&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize${sizeOneOf}
		}
	}
`,
			fixedRepeated: `	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.${fieldName}
		)
		for i := range field {
			${genericTypeCast}(&field[i]).CalculateCanotoCache()
			fieldSize := ${genericTypeCast}(&field[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize${sizeOneOfIndent}
		}
	}
`,
		},
		pointers: typeTemplate{
			single: `	if c.${fieldName} != nil {
		${genericTypeCast}(c.${fieldName}).CalculateCanotoCache()
		if fieldSize := ${genericTypeCast}(c.${fieldName}).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize${sizeOneOfIndent}
		}
	}
`,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				${genericTypeCast}(field[i]).CalculateCanotoCache()
				fieldSize = ${genericTypeCast}(field[i]).CachedCanotoSize()
			}
			size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize${sizeOneOf}
		}
	}
`,
			fixedRepeated: `	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.${fieldName}
		)
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				${genericTypeCast}(field[i]).CalculateCanotoCache()
				fieldSize = ${genericTypeCast}(field[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize${sizeOneOfIndent}
		}
	}
`,
		},
		fields: typeTemplate{
			single: `	c.${fieldName}.CalculateCanotoCache()
	if fieldSize := c.${fieldName}.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize${sizeOneOf}
	}
`,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			size += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize${sizeOneOf}
		}
	}
`,
			fixedRepeated: `	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.${fieldName}
		)
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__${escapedStructName}__${escapedFieldName}__tag)) + ${selector}SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize${sizeOneOfIndent}
		}
	}
`,
		},
	})
}

func makeAssignSizeVars(m message) string {
	var s strings.Builder
	if m.noCopy {
		s.WriteString("\tc.canotoData.size.Store(size)\n")
	} else {
		s.WriteString("\tatomic.StoreUint64(&c.canotoData.size, size)\n")
	}
	for _, oneOf := range m.OneOfs() {
		if m.noCopy {
			_, _ = fmt.Fprintf(&s, "\tc.canotoData.%sOneOf.Store(%sOneOf)\n", oneOf, oneOf)
		} else {
			_, _ = fmt.Fprintf(&s, "\tatomic.StoreUint32(&c.canotoData.%sOneOf, %sOneOf)\n", oneOf, oneOf)
		}
	}
	return s.String()
}

func makeOneOfCacheAccessors(m message) string {
	const template = `

// CachedWhichOneOf${oneOf} returns the previously calculated field number used
// to represent ${oneOf}.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *${structName}${generics}) CachedWhichOneOf${oneOf}() uint32 {
	return ${loadPrefix}c.canotoData.${oneOf}OneOf${loadSuffix}
}`
	var (
		s          strings.Builder
		generics   = makeGenerics(m)
		loadPrefix = "atomic.LoadUint32(&"
		loadSuffix = ")"
	)
	if m.noCopy {
		loadPrefix = ""
		loadSuffix = ".Load()"
	}
	for _, oneOf := range m.OneOfs() {
		_ = writeTemplate(&s, template, map[string]string{
			"oneOf":      oneOf,
			"structName": m.name,
			"generics":   generics,
			"loadPrefix": loadPrefix,
			"loadSuffix": loadSuffix,
		})
	}
	return s.String()
}

func getMarshalTemplate(isOneOf bool) messageTemplate {
	const (
		intTemplateBody = `		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}Append${suffix}(&w, c.${fieldName})
`
		boolTemplateBody = `		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendBool(&w, true)
`
		bytesTemplateBody = `		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendBytes(&w, c.${fieldName})
`
		fixedBytesTemplateBody = `		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendBytes(&w, (&c.${fieldName})[:])
`
		valueTemplateBodyOneOf = `		fieldSize := ${genericTypeCast}(&c.${fieldName}).CachedCanotoSize()
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, fieldSize)
		w = ${genericTypeCast}(&c.${fieldName}).MarshalCanotoInto(w)
`
		pointerTemplateBodyOneOf = `		fieldSize := ${genericTypeCast}(c.${fieldName}).CachedCanotoSize()
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, fieldSize)
		w = ${genericTypeCast}(c.${fieldName}).MarshalCanotoInto(w)
`
		fieldTemplateBodyOneOf = `		fieldSize := c.${fieldName}.CachedCanotoSize()
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, fieldSize)
		w = c.${fieldName}.MarshalCanotoInto(w)
`

		valueTemplateRegular = `	if fieldSize := ${genericTypeCast}(&c.${fieldName}).CachedCanotoSize(); fieldSize != 0 {
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, fieldSize)
		w = ${genericTypeCast}(&c.${fieldName}).MarshalCanotoInto(w)
	}
`
		pointerTemplateRegular = `	if c.${fieldName} != nil {
		if fieldSize := ${genericTypeCast}(c.${fieldName}).CachedCanotoSize(); fieldSize != 0 {
			${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
			${selector}AppendUint(&w, fieldSize)
			w = ${genericTypeCast}(c.${fieldName}).MarshalCanotoInto(w)
		}
	}
`
		fieldTemplateRegular = `	if fieldSize := c.${fieldName}.CachedCanotoSize(); fieldSize != 0 {
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, fieldSize)
		w = c.${fieldName}.MarshalCanotoInto(w)
	}
`
	)

	var (
		intTemplate        = intTemplateBody
		boolTemplate       = boolTemplateBody
		bytesTemplate      = bytesTemplateBody
		fixedBytesTemplate = fixedBytesTemplateBody
		valueTemplate      = valueTemplateBodyOneOf
		pointerTemplate    = pointerTemplateBodyOneOf
		fieldTemplate      = fieldTemplateBodyOneOf
	)

	if !isOneOf {
		intTemplate = "\tif !${selector}IsZero(c.${fieldName}) {\n" + intTemplateBody + "\t}\n"
		boolTemplate = "\tif !${selector}IsZero(c.${fieldName}) {\n" + boolTemplateBody + "\t}\n"
		bytesTemplate = "\tif len(c.${fieldName}) != 0 {\n" + bytesTemplateBody + "\t}\n"
		fixedBytesTemplate = "\tif !${selector}IsZero(c.${fieldName}) {\n" + fixedBytesTemplateBody + "\t}\n"
		valueTemplate = valueTemplateRegular
		pointerTemplate = pointerTemplateRegular
		fieldTemplate = fieldTemplateRegular
	}

	const (
		repeatedFintTemplate = `	if num := uint64(len(c.${fieldName})); num != 0 {
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, num*${selector}Size${suffix})
		for _, v := range c.${fieldName} {
			${selector}Append${suffix}(&w, v)
		}
	}
`
		fixedRepeatedFintTemplate = `	if !${selector}IsZero(c.${fieldName}) {
		const fieldSize = uint64(len(c.${fieldName})) * ${selector}Size${suffix}
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, fieldSize)
		for _, v := range &c.${fieldName} {
			${selector}Append${suffix}(&w, v)
		}
	}
`
		repeatedBytesTemplate = `	for _, v := range c.${fieldName} {
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendBytes(&w, v)
	}
`
	)
	return messageTemplate{
		ints: typeTemplate{
			single: intTemplate,
			repeated: `	if len(c.${fieldName}) != 0 {
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, ${loadPrefix}c.canotoData.${fieldName}Size${loadSuffix})
		for _, v := range c.${fieldName} {
			${selector}Append${suffix}(&w, v)
		}
	}
`,
			fixedRepeated: `	if !${selector}IsZero(c.${fieldName}) {
		${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		${selector}AppendUint(&w, ${loadPrefix}c.canotoData.${fieldName}Size${loadSuffix})
		for _, v := range &c.${fieldName} {
			${selector}Append${suffix}(&w, v)
		}
	}
`,
		},
		fints: typeTemplate{
			single:        intTemplate,
			repeated:      repeatedFintTemplate,
			fixedRepeated: fixedRepeatedFintTemplate,
		},
		bools: typeTemplate{
			single:        boolTemplate,
			repeated:      repeatedFintTemplate,
			fixedRepeated: fixedRepeatedFintTemplate,
		},
		strings: typeTemplate{
			single:   bytesTemplate,
			repeated: repeatedBytesTemplate,
			fixedRepeated: `	if !${selector}IsZero(c.${fieldName}) {
		for _, v := range &c.${fieldName} {
			${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
			${selector}AppendBytes(&w, v)
		}
	}
`,
		},
		bytesTemplate:         bytesTemplate,
		repeatedBytesTemplate: repeatedBytesTemplate,
		fixedBytesTemplate:    fixedBytesTemplate,
		repeatedFixedBytesTemplate: `	{
		field := c.${fieldName}
		for i := range field {
			${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
			${selector}AppendBytes(&w, (&field[i])[:])
		}
	}
`,
		fixedRepeatedBytesTemplate: `	{
		isZero := true
		for _, v := range c.${fieldName} {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.${fieldName} {
				${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
				${selector}AppendBytes(&w, v)
			}
		}
	}
`,
		fixedRepeatedFixedBytesTemplate: `	if !${selector}IsZero(c.${fieldName}) {
		for i := range c.${fieldName} {
			${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
			${selector}AppendBytes(&w, (&(&c.${fieldName})[i])[:])
		}
	}
`,
		values: typeTemplate{
			single: valueTemplate,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
			${selector}AppendUint(&w, ${genericTypeCast}(&field[i]).CachedCanotoSize())
			w = ${genericTypeCast}(&field[i]).MarshalCanotoInto(w)
		}
	}
`,
			fixedRepeated: `	{
		isZero := true
		field := &c.${fieldName}
		for i := range field {
			if ${genericTypeCast}(&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
				${selector}AppendUint(&w, ${genericTypeCast}(&field[i]).CachedCanotoSize())
				w = ${genericTypeCast}(&field[i]).MarshalCanotoInto(w)
			}
		}
	}
`,
		},
		pointers: typeTemplate{
			single: pointerTemplate,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
			var fieldSize uint64
			if field[i] != nil {
				fieldSize = ${genericTypeCast}(field[i]).CachedCanotoSize()
			}
			${selector}AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = ${genericTypeCast}(field[i]).MarshalCanotoInto(w)
			}
		}
	}
`,
			fixedRepeated: `	{
		isZero := true
		field := c.${fieldName}
		for i := range field {
			if field[i] != nil && ${genericTypeCast}(field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
				var fieldSize uint64
				if field[i] != nil {
					fieldSize = ${genericTypeCast}(field[i]).CachedCanotoSize()
				}
				${selector}AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = ${genericTypeCast}(field[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
`,
		},
		fields: typeTemplate{
			single: fieldTemplate,
			repeated: `	{
		field := c.${fieldName}
		for i := range field {
			${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
			fieldSize := field[i].CachedCanotoSize()
			${selector}AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = field[i].MarshalCanotoInto(w)
			}
		}
	}
`,
			fixedRepeated: `	{
		isZero := true
		field := c.${fieldName}
		for i := range field {
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				${selector}Append(&w, canoto__${escapedStructName}__${escapedFieldName}__tag)
				fieldSize := field[i].CachedCanotoSize()
				${selector}AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = field[i].MarshalCanotoInto(w)
				}
			}
		}
	}
`,
		},
	}
}

func makeMarshal(m message) string {
	var (
		regularTmpl = getMarshalTemplate(false)
		oneOfTmpl   = getMarshalTemplate(true)

		s strings.Builder

		currentOneOfName   string
		currentOneOfFields = make([]field, 0, len(m.fields))
		declaredOneOfNames = make(map[string]bool)

		loadPrefix = "atomic.LoadUint32(&"
		loadSuffix = ")"
	)

	if m.noCopy {
		loadPrefix = ""
		loadSuffix = ".Load()"
	}

	flushOneOf := func() {
		if len(currentOneOfFields) == 0 {
			return
		}

		varName := "cachedWhichOneOf" + currentOneOfName
		if !declaredOneOfNames[currentOneOfName] {
			_, _ = fmt.Fprintf(&s, "\t%s := %sc.canotoData.%sOneOf%s\n", varName, loadPrefix, currentOneOfName, loadSuffix)
			declaredOneOfNames[currentOneOfName] = true
		}

		if len(currentOneOfFields) == 1 {
			_, _ = fmt.Fprintf(&s, "\tif %s == %d {\n", varName, currentOneOfFields[0].fieldNumber)
			_ = writeField(&s, currentOneOfFields[0], oneOfTmpl)
		} else {
			fmt.Fprintf(&s, "\tswitch %s {\n", varName)
			for _, field := range currentOneOfFields {
				_, _ = fmt.Fprintf(&s, "\tcase canoto__%s__%s:\n", m.canonicalizedName, field.canonicalizedName)
				_ = writeField(&s, field, oneOfTmpl)
			}
		}

		s.WriteString("\t}\n")
		currentOneOfName = ""
		currentOneOfFields = currentOneOfFields[:0]
	}

	for _, f := range m.fields {
		if f.oneOfName != "" && f.oneOfName == currentOneOfName {
			currentOneOfFields = append(currentOneOfFields, f)
			continue
		}

		flushOneOf()

		if f.oneOfName == "" {
			_ = writeField(&s, f, regularTmpl)
			continue
		}

		currentOneOfName = f.oneOfName
		currentOneOfFields = append(currentOneOfFields, f)
	}

	flushOneOf()

	return s.String()
}

type messageTemplate struct {
	ints    typeTemplate
	fints   typeTemplate
	bools   typeTemplate
	strings typeTemplate

	bytesTemplate                   string
	repeatedBytesTemplate           string
	fixedBytesTemplate              string
	repeatedFixedBytesTemplate      string
	fixedRepeatedBytesTemplate      string
	fixedRepeatedFixedBytesTemplate string

	values   typeTemplate
	pointers typeTemplate
	fields   typeTemplate
}

type typeTemplate struct {
	single        string
	repeated      string
	fixedRepeated string
}

func writeMessage(m message, t messageTemplate) string {
	var s strings.Builder
	for _, f := range m.fields {
		_ = writeField(&s, f, t)
	}
	return s.String()
}

func writeField(w io.Writer, f field, t messageTemplate) error {
	var template string
	switch c := f.canotoType; c {
	case canotoInt, canotoUint:
		template = t.ints.single
	case canotoRepeatedInt, canotoRepeatedUint:
		template = t.ints.repeated
	case canotoFixedRepeatedInt, canotoFixedRepeatedUint:
		template = t.ints.fixedRepeated
	case canotoFint32, canotoFint64:
		template = t.fints.single
	case canotoRepeatedFint32, canotoRepeatedFint64:
		template = t.fints.repeated
	case canotoFixedRepeatedFint32, canotoFixedRepeatedFint64:
		template = t.fints.fixedRepeated
	case canotoBool:
		template = t.bools.single
	case canotoRepeatedBool:
		template = t.bools.repeated
	case canotoFixedRepeatedBool:
		template = t.bools.fixedRepeated
	case canotoString:
		template = t.strings.single
	case canotoRepeatedString:
		template = t.strings.repeated
	case canotoFixedRepeatedString:
		template = t.strings.fixedRepeated
	case canotoBytes:
		template = t.bytesTemplate
	case canotoFixedBytes:
		template = t.fixedBytesTemplate
	case canotoRepeatedBytes:
		template = t.repeatedBytesTemplate
	case canotoRepeatedFixedBytes:
		template = t.repeatedFixedBytesTemplate
	case canotoFixedRepeatedBytes:
		template = t.fixedRepeatedBytesTemplate
	case canotoFixedRepeatedFixedBytes:
		template = t.fixedRepeatedFixedBytesTemplate
	case canotoValue:
		template = t.values.single
	case canotoRepeatedValue:
		template = t.values.repeated
	case canotoFixedRepeatedValue:
		template = t.values.fixedRepeated
	case canotoPointer:
		template = t.pointers.single
	case canotoRepeatedPointer:
		template = t.pointers.repeated
	case canotoFixedRepeatedPointer:
		template = t.pointers.fixedRepeated
	case canotoField:
		template = t.fields.single
	case canotoRepeatedField:
		template = t.fields.repeated
	default:
		template = t.fields.fixedRepeated
	}
	return writeTemplate(w, template, f.templateArgs)
}

func makeTemplate(template string, args map[string]string) string {
	return os.Expand(template, func(key string) string {
		return args[key]
	})
}

func writeTemplate(w io.Writer, template string, args map[string]string) error {
	s := makeTemplate(template, args)
	_, err := w.Write([]byte(s))
	return err
}
